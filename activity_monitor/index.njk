<!-- ACTIVITY MONITOR WINDOW (Tailwind) -->
<div class="window pixel-corners bg-gray-800 shadow-lg rounded-lg overflow-hidden fixed bottom-8 right-5"
     style="width: 400px; height: 300px;">
  <div data-part="handle" class="window_title bg-gray-800 text-gray-100 font-semibold">
    <div class="float-right">
      <button
        class="icon close_dark mr-1 hint--left text-gray-100"
        aria-label="Close (ESC)"
        data-close
      >&times;</button>
    </div>
    <div data-part="title" class="title_bg">Activity Monitor</div>
  </div>

  <div class="p-2 bg-gray-800">
    <div id="fpsMonitorContainer" class="w-full h-48 bg-gray-800 rounded-md">
      <canvas id="fpsChart" class="w-full" style="height: 280px;"></canvas>
    </div>
  </div>

  <div class="resize-handle"></div>
</div>

<script>
window[id] = {
  id: id,
  dpr: 1,
  hiddenFunctions: {},
  lastRenderTime: 0, // Track the last time we actually drew the chart

  start: function() {
    this.setupCanvas();
    window.addEventListener('resize', this.onResize.bind(this));
  },

  // Throttle chart rendering to once per second
  onRender: function() {
    const now = performance.now();
    if (now - this.lastRenderTime >= 1000) {
      this.lastRenderTime = now;
      this.renderChart();
    }
  },

  setupCanvas: function() {
    const canvas = document.getElementById('fpsChart');
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    this.dpr = window.devicePixelRatio || 1;
    canvas.width = canvas.offsetWidth * this.dpr;
    canvas.height = canvas.offsetHeight * this.dpr;
    ctx.scale(this.dpr, this.dpr);

    canvas.addEventListener('click', this.handleCanvasClick.bind(this));
    this.renderChart();
  },

  onResize: function() {
    this.setupCanvas();
  },

  handleCanvasClick: function(event) {
    const canvas = event.target;
    const rect = canvas.getBoundingClientRect();
    const x = (event.clientX - rect.left) * this.dpr;
    const y = (event.clientY - rect.top) * this.dpr;

    let functionCalls = {};
    if (plugin.exists('debug') && window.debug && window.debug.functionCalls) {
      functionCalls = window.debug.functionCalls;
    }

    const trackedFunctions = Object.keys(functionCalls);
    const labelArea = 15;

    // Toggle each function's hidden state if we click its label
    trackedFunctions.forEach((functionName, index) => {
      const labelY = 20 + index * labelArea;
      if (y > labelY - 10 && y < labelY + 5) {
        this.hiddenFunctions[functionName] = !this.hiddenFunctions[functionName];
        this.renderChart();
      }
    });
  },

  renderChart: function() {
    const canvas = document.getElementById('fpsChart');
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const dpr = this.dpr;

    let functionCalls = {};
    if (plugin.exists('debug') && window.debug && window.debug.functionCalls) {
      functionCalls = window.debug.functionCalls;
    }

    // Filter out functions that are always 0
    const trackedFunctions = Object.keys(functionCalls).filter((fnName) => {
      const { countHistory, valueHistory } = functionCalls[fnName];
      if (!countHistory || !valueHistory) return false;
      const latestCount = countHistory[countHistory.length - 1] || 0;
      const latestValue = valueHistory[valueHistory.length - 1] || 0;
      return !(latestCount === 0 && latestValue === 0);
    });

    // Find global max
    let globalMaxValue = 0;
    trackedFunctions.forEach((fnName) => {
      const { countHistory, valueHistory } = functionCalls[fnName];
      const localMax = Math.max(...countHistory, ...valueHistory);
      if (localMax > globalMaxValue) globalMaxValue = localMax;
    });
    const maxValue = Math.ceil(globalMaxValue * 1.1);

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const padding = 30;
    const chartHeight = canvas.height / dpr - 2 * padding;
    const chartWidth = canvas.width / dpr - 2 * padding;

    const formatMetric = (num) => (Number.isInteger(num) ? num : num.toFixed(2));
    const numberOfLabels = 5;
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.font = '12px Arial';

    // Horizontal lines + left/right labels
    for (let i = 0; i <= numberOfLabels; i++) {
      const value = Math.round((i / numberOfLabels) * maxValue);
      const y = canvas.height / dpr - padding - (value / maxValue) * chartHeight;
      ctx.textAlign = 'left';
      ctx.fillText(value, 5, y + 4);
      ctx.textAlign = 'right';
      ctx.fillText(value, (canvas.width / dpr) - 5, y + 4);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.beginPath();
      ctx.moveTo(padding, y);
      ctx.lineTo(canvas.width / dpr - padding, y);
      ctx.stroke();
    }

    // Draw lines for each function
    trackedFunctions.forEach((fnName, index) => {
      const { countHistory, valueHistory } = functionCalls[fnName];
      const length = countHistory.length;
      if (this.hiddenFunctions[fnName]) return;

      // Base color for lines
      const baseColor = `hsl(${(index / trackedFunctions.length) * 360}, 70%, 60%)`;

      // Count line
      ctx.strokeStyle = baseColor;
      ctx.lineWidth = 2;
      ctx.beginPath();
      countHistory.forEach((count, i) => {
        const x = padding + (i / (length - 1)) * chartWidth;
        const y = canvas.height / dpr - padding - (count / maxValue) * chartHeight;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      });
      ctx.stroke();

      // Value line
      ctx.strokeStyle = `rgba(${parseInt((index / trackedFunctions.length) * 255)}, 255, 255, 0.7)`;
      ctx.beginPath();
      valueHistory.forEach((val, i) => {
        const x = padding + (i / (length - 1)) * chartWidth;
        const y = canvas.height / dpr - padding - (val / maxValue) * chartHeight;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      });
      ctx.stroke();
    });

    // Labels for each function
    trackedFunctions.forEach((fnName, index) => {
      const { countHistory, valueHistory } = functionCalls[fnName];
      const latestCount = countHistory[countHistory.length - 1] || 0;
      const latestValue = valueHistory[valueHistory.length - 1];
      const displayMetric = (typeof latestValue === 'number' ? latestValue : latestCount) || 0;
      const baseColor = `hsl(${(index / trackedFunctions.length) * 360}, 70%, 60%)`;
      const labelX = padding + 5;
      const labelY = 20 + index * 15;
      const labelText = `${fnName}: ${formatMetric(displayMetric)}`;

      // Black background behind the label
      ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
      ctx.textAlign = 'left';
      const textWidth = ctx.measureText(labelText).width;
      const textHeight = 12;
      ctx.fillRect(labelX - 2, labelY - textHeight + 2, textWidth + 4, textHeight + 4);

      // Draw label text
      ctx.fillStyle = baseColor;
      ctx.fillText(labelText, labelX, labelY);

      // Cross out the label if hidden
      if (this.hiddenFunctions[fnName]) {
        ctx.strokeStyle = baseColor;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(labelX, labelY - 5);
        ctx.lineTo(labelX + textWidth, labelY - 5);
        ctx.stroke();
      }
    });
  }
};
</script>
