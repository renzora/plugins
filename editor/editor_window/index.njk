{% if auth %}
<div
  id="editor_toolbar_buttons"
  class="fixed top-2 bg-black/80 text-white rounded-lg shadow-lg p-2 flex gap-2 overflow-x-auto"
>
  <button
    type="button"
    id="select_button"
    class="mode-button shadow flex items-center justify-center hover:bg-gray-700 hover:rounded transition"
    onclick="editor_window.changeMode('select')"
  >
  </button>
  <button
    type="button"
    id="pan_button"
    class="mode-button shadow flex items-center justify-center hover:bg-gray-700 hover:rounded transition"
    onclick="editor_window.changeMode('pan')"
  >
  </button>
  <button
    type="button"
    id="lasso_button"
    class="mode-button shadow flex items-center justify-center hover:bg-gray-700 hover:rounded transition"
    onclick="editor_window.changeMode('lasso')"
  >
  </button>
  <button
    type="button"
    id="move_button"
    class="mode-button shadow flex items-center justify-center hover:bg-gray-700 hover:rounded transition"
    onclick="editor_window.changeMode('move')"
  >
  </button>
  <button
    type="button"
    id="save_button"
    class="mode-button shadow flex items-center justify-center hover:bg-gray-700 hover:rounded transition"
    onclick="editor_window.saveRoomData()"
  >
  </button>
  <button
    type="button"
    id="rotate_button"
    class="mode-button shadow flex items-center justify-center hover:bg-gray-700 hover:rounded transition"
    onclick="editor_window.rotateObjects()"
  >
  </button>
  <button
    type="button"
    id="close_button"
    class="mode-button shadow flex items-center justify-center hover:bg-gray-700 hover:rounded transition"
    onclick="plugin.close('editor_window')"
  >
  </button>
</div>

<style>
  body.move-cursor {
    cursor: move !important;
  }
</style>

<script>
editor_window = {
  renderMode: 'isometric',
  originalRoomData: JSON.parse(JSON.stringify(game.roomData)),
  modeButtons: {},
  brushRadius: 16,
  isBrushModeActive: false,
  isPanning: false,
  isMiddleClickPanning: false,
  mouseX: 0,
  mouseY: 0,
  lastMouseX: 0,
  lastMouseY: 0,
  defaultCursor: 'default',
  previousMode: null,
  modes: ['select', 'zoom', 'delete', 'pan', 'lasso', 'move'],
  lassoPath: [],
  isLassoActive: false,
  boundMouseMoveHandler: null,
  boundMouseDownHandler: null,
  boundMouseUpHandler: null,
  boundMouseScrollHandler: null,
  boundKeyDownHandler: null,
  clipboard: [],
  isAddingNewObject: false,
  isDragging: false,
  selectionStart: { x: 0, y: 0 },
  selectionEnd: { x: 0, y: 0 },
  selectedObjects: [],
  undoStack: [],
  redoStack: [],
  isMovingObjects: false,
  moveOffsetX: 0,
  moveOffsetY: 0,
  currentHour: null,
  currentMinute: null,
  currentDay: null,
  isSnapEnabled: false,
  isGroupObjectsEnabled: false,
  dragStartAxis: null,
  hoveredAxis: null,
  iconPositions: {
    pencil: 0,
    scissors: 1,
    zoom: 2,
    save: 4,
    trash: 5,
    undo: 6,
    redo: 7,
    select: 8,
    eye: 9,
    move: 10,
    pan: 11,
    cancel: 12,
    rotate: 13
  },

  start() {
    assets.preload([{ name: 'edit_mode_window_icons', path: 'plugins/editor/editor_window/icons.png' }], () => {
      this.setButtonIcon('select_button', 'select')
      this.setButtonIcon('pan_button', 'pan')
      this.setButtonIcon('lasso_button', 'pencil')
      this.setButtonIcon('move_button', 'move')
      this.setButtonIcon('save_button', 'save')
      this.setButtonIcon('rotate_button', 'rotate')
      this.setButtonIcon('close_button', 'cancel')
    })

    this.modeButtons = {
      select: document.getElementById('select_button'),
      zoom: document.getElementById('zoom_button'),
      delete: document.getElementById('delete_button'),
      pan: document.getElementById('pan_button'),
      lasso: document.getElementById('lasso_button'),
      move: document.getElementById('move_button')
    }

    plugin.time.active = true
    game.isEditMode = true
    game.pathfinding = false
    game.allowControls = true
    camera.lerpEnabled = false
    game.zoomLevel = 4
    plugin.actions.tooltipActive = false
    plugin.pathfinding.stopPathfinding()
    plugin.actions.hideTooltip()

    this.updateCurrentTimeAndDay()
    this.boundMouseMoveHandler = this.handleMouseMove.bind(this)
    this.boundMouseDownHandler = this.handleMouseDown.bind(this)
    this.boundMouseUpHandler = this.handleMouseUp.bind(this)
    this.boundMouseScrollHandler = this.handleMouseScroll.bind(this)
    this.boundKeyDownHandler = this.handleKeyDown.bind(this)

    game.canvas.addEventListener('mousemove', this.boundMouseMoveHandler)
    game.canvas.addEventListener('mousedown', this.boundMouseDownHandler)
    game.canvas.addEventListener('mouseup', this.boundMouseUpHandler)
    game.canvas.addEventListener('wheel', this.boundMouseScrollHandler)
    window.addEventListener('keyup', this.handleKeyUp.bind(this))
    window.addEventListener('keydown', this.boundKeyDownHandler)

    plugin.console_window.load_tab_buttons('editor')
    plugin.console_window.toggleConsoleWindow('editor_inventory')
    plugin.console_window.allowToggle = false

    plugin.preload([
      { priority: 0, id: 'editor_layers', path: 'editor', ext: 'njk', drag: false, reload: false },
      { priority: 1, id: 'editor_context_menu', path: 'editor', ext: 'njk', drag: false, reload: true }
    ])

    setTimeout(() => { camera.manual = true }, 0)
    this.changeMode('select')
  },

  unmount() {
    game.isEditMode = false
    game.pathfinding = true
    game.allowControls = true
    plugin.time.active = true
    plugin.time.hours = this.currentHour
    plugin.time.minutes = this.currentMinute
    game.displaySprite = true
    camera.lerpEnabled = true
    camera.manual = false
    game.zoomLevel = 4
    game.canvas.removeEventListener('mousemove', this.boundMouseMoveHandler)
    game.canvas.removeEventListener('mousedown', this.boundMouseDownHandler)
    game.canvas.removeEventListener('mouseup', this.boundMouseUpHandler)
    game.canvas.removeEventListener('wheel', this.boundMouseScrollHandler)
    window.removeEventListener('keydown', this.boundKeyDownHandler)
    window.removeEventListener('keyup', this.boundKeyUpHandler)

    this.isDragging = false
    this.isLassoActive = false
    this.selectedObjects = []
    this.lassoPath = []
    this.selectionStart = { x: 0, y: 0 }
    this.selectionEnd = { x: 0, y: 0 }
    this.isMovingObjects = false
    this.isMiddleClickPanning = false
    plugin.actions.tooltipActive = true

    this.clearSelectionBox()
    this.clearLassoPath()

    document.body.style.cursor = 'default'
    plugin.close('editor_context_menu')
    plugin.close('console_window')
    plugin.close('editor_layers')
    plugin.showAll();
    assets.unload('edit_mode_window_icons')
    game.resizeCanvas()
  },

  onRender() {
    this.renderSelectionBox()
    this.renderSelectedTiles()
    this.renderLasso()
  },

  setButtonIcon: function(buttonId, iconName) {
    const buttonEl = document.getElementById(buttonId)
    if (!buttonEl) return

    const canvas = document.createElement('canvas')
    const ctx = canvas.getContext('2d')

    canvas.width = 32
    canvas.height = 32

    const iconIndex = this.iconPositions[iconName]
    const iconSprite = assets.use('edit_mode_window_icons')
    const offsetX = iconIndex * 32
    ctx.drawImage(iconSprite, offsetX, 0, 32, 32, 0, 0, 32, 32)
    buttonEl.appendChild(canvas)
  },

  updateCurrentTimeAndDay() {
    if(!plugin.time) return
    this.currentHour = Math.floor(time.hours)
    this.currentMinute = Math.floor(time.minutes)
    this.currentDay = time.daysOfWeek[time.days % 7]
  },

  changeMode(newMode) {
    const contextMenu = document.getElementById('editor_context_menu')
    if (contextMenu) {
      contextMenu.classList.add('hidden')
    }

    if (this.isDragging) {
      return
    }

    if (game.editorMode === newMode) return

    document.body.style.cursor = 'default'
    game.editorMode = newMode
    this.isBrushModeActive = false
    this.isLassoActive = false
    this.isPanning = false

    switch (newMode) {
      case 'select':
        this.defaultCursor = 'pointer'
        break
      case 'pan':
        this.defaultCursor = 'grab'
        this.isPanning = true
        break
      case 'lasso':
        this.defaultCursor = 'crosshair'
        this.isLassoActive = true
        break
      default:
        this.defaultCursor = 'default'
    }

    document.body.style.cursor = this.defaultCursor

    const buttons = document.querySelectorAll('.mode-button')
    buttons.forEach(button => {
      button.classList.remove('active')
      if (button.id === `${newMode}_button`) {
        button.classList.add('active')
      }
    })
  },

handleMouseMove(event) {
  const rect = game.canvas.getBoundingClientRect();
  this.mouseX = (event.clientX - rect.left) / game.zoomLevel + camera.cameraX;
  this.mouseY = (event.clientY - rect.top) / game.zoomLevel + camera.cameraY;

  if (event.buttons === 4 && this.isMiddleClickPanning) {
    const deltaX = event.clientX - this.lastMouseX;
    const deltaY = event.clientY - this.lastMouseY;
    const margin = 1000;
    const minX = -margin / game.zoomLevel;
    const minY = -margin / game.zoomLevel;
    const maxX = (game.worldWidth - window.innerWidth / game.zoomLevel) + margin / game.zoomLevel;
    const maxY = (game.worldHeight - window.innerHeight / game.zoomLevel) + margin / game.zoomLevel;
    camera.cameraX = Math.max(minX, Math.min(maxX, camera.cameraX - deltaX / game.zoomLevel));
    camera.cameraY = Math.max(minY, Math.min(maxY, camera.cameraY - deltaY / game.zoomLevel));
    this.lastMouseX = event.clientX;
    this.lastMouseY = event.clientY;
    return;
  }

  if (this.isDragging && event.buttons === 1) {
    if (game.editorMode === 'move') {
      this.handleObjectMovement();
      return;
    }
    if (game.editorMode === 'lasso') {
      this.lassoPath.push({ x: this.mouseX, y: this.mouseY });
      this.renderLasso();
      return;
    }
  }

  if (game.editorMode === 'move' && this.selectedObjects.length > 0 && !this.isDragging) {
    let globalMinX = Infinity, globalMinY = Infinity, globalMaxX = -Infinity, globalMaxY = -Infinity;
    this.selectedObjects.forEach(obj => {
      let tileMinX = Math.min(...obj.x) * 16;
      let tileMaxX = Math.max(...obj.x) * 16 + 16;
      let tileMinY = Math.min(...obj.y) * 16;
      let tileMaxY = Math.max(...obj.y) * 16 + 16;
      const pivotX = (tileMinX + tileMaxX) / 2;
      const pivotY = tileMaxY;
      const scale = obj.scale || 1;
      const widthScaled = (tileMaxX - tileMinX) * scale;
      const heightScaled = (tileMaxY - tileMinY) * scale;
      const objMinX = pivotX - widthScaled / 2;
      const objMinY = pivotY - heightScaled;
      const objMaxX = pivotX + widthScaled / 2;
      const objMaxY = pivotY;
      globalMinX = Math.min(globalMinX, objMinX);
      globalMinY = Math.min(globalMinY, objMinY);
      globalMaxX = Math.max(globalMaxX, objMaxX);
      globalMaxY = Math.max(globalMaxY, objMaxY);
    });
    const centerX = (globalMinX + globalMaxX) / 2;
    const centerY = (globalMinY + globalMaxY) / 2;
    const centerCircleRadius = 10 / game.zoomLevel;
    const distToCenter = Math.sqrt(
      Math.pow(this.mouseX - centerX, 2) + Math.pow(this.mouseY - centerY, 2)
    );
    if (distToCenter <= centerCircleRadius) {
      this.hoveredAxis = 'center';
      document.body.style.cursor = 'move';
      return;
    }
    this.hoveredAxis = null;
    document.body.style.cursor = this.defaultCursor;
  }

  if (game.editorMode === 'pan' && this.isPanning && event.buttons === 1) {
    const deltaX = event.clientX - this.lastMouseX;
    const deltaY = event.clientY - this.lastMouseY;
    camera.cameraX -= deltaX / game.zoomLevel;
    camera.cameraY -= deltaY / game.zoomLevel;
    this.constrainCamera();
    this.lastMouseX = event.clientX;
    this.lastMouseY = event.clientY;
    return;
  }

  if (this.isDragging && event.buttons === 1) {
    if (game.editorMode === 'select') {
      this.handleSelectionBox(event, rect);
    }
  }
},

handleMouseDown(e) {
  if (plugin.editor_window.isAddingNewObject) return;

  if (game.editorMode === 'pan') {
    this.isPanning = true;
    this.lastMouseX = e.clientX;
    this.lastMouseY = e.clientY;
    document.body.style.cursor = 'grabbing';
    return;
  }

  this.updateMousePosition(e);

  if (e.button === 2) {
    const isClickInsideSelection = this.isCursorInsideSelectedArea();
    if (!isClickInsideSelection) {
      this.selectedObjects = [];
      this.clearSelectionBox();
      this.clearLassoPath();
      this.changeMode('select');
    }
    return;
  }

  if (e.button === 1) {
    this.previousMode = game.editorMode;
    this.changeMode('pan');
    this.isMiddleClickPanning = true;
    this.isPanning = true;
    this.lastMouseX = e.clientX;
    this.lastMouseY = e.clientY;
    document.body.style.cursor = 'grabbing';
    return;
  }

  if (e.button === 0) {
    if (e.shiftKey) {
      const clickedObject = this.findTopmostObjectWithPixelCheck(this.mouseX, this.mouseY, true);
      if (clickedObject && !this.isObjectLocked(clickedObject)) {
        const index = this.selectedObjects.indexOf(clickedObject);
        if (index === -1) {
          this.selectedObjects.push(clickedObject);
          const layerIds = this.selectedObjects.map(obj => "item_" + obj.layer_id);
          editor_layers.selectLayersById(layerIds);
        } else {
          this.selectedObjects.splice(index, 1);
          const layerIds = this.selectedObjects.map(obj => "item_" + obj.layer_id);
          editor_layers.selectLayersById(layerIds);
        }
        if (this.selectedObjects.length === 0) {
          this.changeMode('select');
        } else {
          this.changeMode('move');
        }
        return;
      }
    }

    if (game.editorMode === 'lasso') {
      this.isDragging = true;
      this.lassoPath = [{ x: this.mouseX, y: this.mouseY }];
      return;
    }

    if (game.editorMode === 'move') {
      if (this.hoveredAxis === 'center') {
        this.isDragging = true;
        this.dragStartAxis = 'center';
        this.lastMouseX = this.mouseX;
        this.lastMouseY = this.mouseY;
        this.clearSelectionBox();
        return;
      }

      const clickedItem = this.findTopmostObjectWithPixelCheck(this.mouseX, this.mouseY, true);
      if (clickedItem) {
        if (!this.selectedObjects.includes(clickedItem)) {
          this.selectedObjects = [clickedItem];
          editor_layers.selectLayersById(['item_' + clickedItem.layer_id]);
          this.panCameraToObject(clickedItem);
          this.clearSelectionBox();
          this.renderSelectedTiles();
        }
      } else if (!this.checkIfClickedOnSelectedObject()) {
        this.changeMode('select');
        this.handleSelectionStart(e);
      }
      return;
    }

    if (game.editorMode === 'select') {
      if (!this.isDragging) {
        const clickedItem = this.findTopmostObjectWithPixelCheck(this.mouseX, this.mouseY, true);
        if (clickedItem) {
          if (!this.selectedObjects.includes(clickedItem)) {
            this.selectedObjects = [clickedItem];
            editor_layers.selectLayersById(['item_' + clickedItem.layer_id]);
            this.panCameraToObject(clickedItem);
          }
          this.clearSelectionBox();
          this.changeMode('move');
          this.renderSelectedTiles();
          return;
        }
      }
      this.handleSelectionStart(e);
    }
  }
},

  handleMouseUp(event) {
    if (event.button === 1 && this.isMiddleClickPanning) {
      this.isMiddleClickPanning = false
      this.isPanning = false
      this.changeMode(this.previousMode)
      document.body.style.cursor = this.defaultCursor
      return
    }

    if (event.button === 0) {
      this.isDragging = false
      this.dragStartAxis = null

      if (this.isPanning) {
        this.isPanning = false
        document.body.style.cursor = this.defaultCursor
      }

      if (game.editorMode === 'lasso') {
        if (this.lassoPath.length > 2) {
          this.updateSelectedObjectsWithLasso(event.shiftKey)
        }
        this.clearLassoPath()
        return
      }

      if (this.handleSelectionEnd(event)) return

      if (game.editorMode === 'move') {
        this.finalizeObjectMovement()
      }
    }
  },

  handleMouseScroll(event) {
    if (!game.isEditMode) return
    const zoomFactor = event.deltaY < 0 ? 1 : -1
    const newZoomLevel = Math.max(2, Math.min(game.zoomLevel + zoomFactor, 10))
    const rect = game.canvas.getBoundingClientRect()
    const mouseXOnCanvas = event.clientX - rect.left
    const mouseYOnCanvas = event.clientY - rect.top
    const worldMouseX = mouseXOnCanvas / game.zoomLevel + camera.cameraX
    const worldMouseY = mouseYOnCanvas / game.zoomLevel + camera.cameraY
    game.zoomLevel = newZoomLevel
    const newWorldMouseX = mouseXOnCanvas / game.zoomLevel + camera.cameraX
    const newWorldMouseY = mouseYOnCanvas / game.zoomLevel + camera.cameraY
    camera.cameraX += worldMouseX - newWorldMouseX
    camera.cameraY += worldMouseY - newWorldMouseY
    this.constrainCamera()
  },

findTopmostObjectWithPixelCheck(worldX, worldY, allowSameOrHigherZ = false) {
   const items = [...game.roomData.items]
   
   const itemsWithinBounds = items.filter(rItem => {
       const minX = Math.min(...rItem.x) * 16
       const maxX = Math.max(...rItem.x) * 16 + 16
       const minY = Math.min(...rItem.y) * 16
       const maxY = Math.max(...rItem.y) * 16 + 16
       
       return (
           worldX >= minX && 
           worldX <= maxX && 
           worldY >= minY && 
           worldY <= maxY
       )
   })

   let selectedZ = -Infinity;
   if (this.selectedObjects.length > 0) {
       const selectedObj = this.selectedObjects[0];
       const selectedMaxY = Math.max(...selectedObj.y);
       const selectedData = game.objectData[selectedObj.id]?.[0];
       selectedZ = selectedData?.z === 0 ? -9999 : selectedMaxY * 16;
   }

   const sortedItems = itemsWithinBounds.map(rItem => {
       const tData = game.objectData[rItem.id]?.[0]
       const maxY = Math.max(...rItem.y)
       let zIndex = tData?.z === 0 ? -9999 : maxY * 16
       
       return { rItem, zIndex }
   }).sort((a, b) => b.zIndex - a.zIndex)

   for (const { rItem, zIndex } of sortedItems) {
       if (rItem.visible === false || this.isObjectLocked(rItem)) {
           continue
       }

       if (this.selectedObjects.includes(rItem)) {
           return rItem;
       }

       if (!allowSameOrHigherZ && zIndex < selectedZ) {
           continue;
       }

       const tileDataArray = game.objectData[rItem.id]
       if (!tileDataArray?.length) {
           continue
       }
       
       const tileData = tileDataArray[0]
       const frame = tileData.currentFrame || 0
       const cacheKey = `${rItem.id}_${frame}`
       const offscreen = game.objectCache[cacheKey]
       if (!offscreen) {
           continue
       }

       const minX = Math.min(...rItem.x) * 16
       const minY = Math.min(...rItem.y) * 16
       const px = Math.floor(worldX - minX)
       const py = Math.floor(worldY - minY)
       
       if (px < 0 || px >= offscreen.width || py < 0 || py >= offscreen.height) {
           continue
       }

       const offCtx = offscreen.getContext('2d')
       const pixel = offCtx.getImageData(px, py, 1, 1).data
       
       if (pixel[3] > 0) {
           return rItem
       }
   }
   
   return null
},

  getRoomItemZIndex(rItem) {
    const iData = game.objectData[rItem.id]
    if (!iData || !iData.length) return Number.MIN_SAFE_INTEGER
    const tData = iData[0]
    if (tData.z === 0) return -9999
    const maxY = Math.max(...rItem.y)
    return maxY * 16
  },

  isCursorInsideSelectedArea() {
    return this.selectedObjects.some(obj => {
      const objRect = {
        x: Math.min(...obj.x) * 16,
        y: Math.min(...obj.y) * 16,
        width: (Math.max(...obj.x) - Math.min(...obj.x) + 1) * 16,
        height: (Math.max(...obj.y) - Math.min(...obj.y) + 1) * 16
      }

      return (
        this.mouseX >= objRect.x &&
        this.mouseX <= objRect.x + objRect.width &&
        this.mouseY >= objRect.y &&
        this.mouseY <= objRect.y + objRect.height
      )
    })
  },

  handlePanning(event) {
    if (event.button === 1 || game.editorMode === 'pan') {
      this.isDragging = true
      this.isPanning = true
      this.lastMouseX = event.clientX
      this.lastMouseY = event.clientY
      document.body.style.cursor = 'grabbing'
      return true
    }
    return false
  },

  handleCameraPanning: function(event) {
    const deltaX = event.clientX - this.lastMouseX
    const deltaY = event.clientY - this.lastMouseY
    camera.cameraX -= deltaX / game.zoomLevel
    camera.cameraY -= deltaY / game.zoomLevel
    this.constrainCamera()
    this.lastMouseX = event.clientX
    this.lastMouseY = event.clientY
  },

  handleZoomDrag(event) {
    if (event.button === 0) {
      this.isDragging = true
      this.lastMouseY = event.clientY
      return true
    }
    return false
  },

  handleObjectMovement() {
    if (!this.selectedObjects.length) return
    if (this.dragStartAxis !== 'center') return

    let totalDeltaX = this.mouseX - this.lastMouseX
    let totalDeltaY = this.mouseY - this.lastMouseY

    this.selectedObjects.forEach((obj) => {
      obj.x = obj.x.map(coord => coord + totalDeltaX / 16)
      obj.y = obj.y.map(coord => coord + totalDeltaY / 16)
    })

    this.lastMouseX = this.mouseX
    this.lastMouseY = this.mouseY
  },

  handleSelectionStart(event) {
    if (plugin.editor_window.isAddingNewObject) return
    this.isDragging = true
    const rect = game.canvas.getBoundingClientRect()
    this.selectionStart = {
      x: (event.clientX - rect.left) / game.zoomLevel + camera.cameraX,
      y: (event.clientY - rect.top) / game.zoomLevel + camera.cameraY
    }
    this.selectionEnd = { ...this.selectionStart }

    if (!event.shiftKey) {
      this.selectedObjects = []
    }
  },

  handleSelectionBox: function(event, rect) {
    if (game.editorMode === 'select' || (game.editorMode === 'move' && event.shiftKey)) {
      this.selectionEnd = {
        x: (event.clientX - rect.left) / game.zoomLevel + camera.cameraX,
        y: (event.clientY - rect.top) / game.zoomLevel + camera.cameraY
      }
      this.renderSelectionBox()
      const edgeThreshold = 50
      const viewportWidth = window.innerWidth
      const viewportHeight = window.innerHeight
      const canvasStyle = game.canvas.style
      const canvasLeft = parseInt(canvasStyle.left || '0', 10)
      const canvasTop = parseInt(canvasStyle.top || '0', 10)

      if (event.clientX < edgeThreshold) {
        if (camera.cameraX > 0) {
          camera.cameraX -= 5
        } else {
          game.canvas.style.left = `${Math.min(canvasLeft + 5, 0)}px`
        }
      } else if (event.clientX > viewportWidth - edgeThreshold) {
        const maxCameraX = game.worldWidth - viewportWidth / game.zoomLevel
        if (camera.cameraX < maxCameraX) {
          camera.cameraX += 5
        } else {
          game.canvas.style.left = `${Math.max(canvasLeft - 5, viewportWidth - rect.width)}px`
        }
      }

      if (event.clientY < edgeThreshold) {
        if (camera.cameraY > 0) {
          camera.cameraY -= 5
        } else {
          game.canvas.style.top = `${Math.min(canvasTop + 5, 0)}px`
        }
      } else if (event.clientY > viewportHeight - edgeThreshold) {
        const maxCameraY = game.worldHeight - viewportHeight / game.zoomLevel
        if (camera.cameraY < maxCameraY) {
          camera.cameraY += 5
        } else {
          game.canvas.style.top = `${Math.max(canvasTop - 5, viewportHeight - rect.height)}px`
        }
      }

      this.constrainCamera()
    }
  },

  handleLassoStart(event) {
    if (event.button === 0) {
      this.isDragging = true
      this.lassoPath = [{ x: this.mouseX, y: this.mouseY }]
      return true
    }
    return false
  },

  handleLassoDragging() {
    this.lassoPath.push({ x: this.mouseX, y: this.mouseY })
    this.renderLasso()
  },

  handleMoveMode(event) {
    const clickedOnSelectedObject = this.checkIfClickedOnSelectedObject()

    if (!clickedOnSelectedObject) {
      this.changeToSelectModeAndStart(event)
    } else {
      this.startObjectMove(event)
    }
  },

  checkIfClickedOnSelectedObject() {
    return this.selectedObjects.some(obj => {
      const objRect = {
        x: Math.min(...obj.x) * 16,
        y: Math.min(...obj.y) * 16,
        width: (Math.max(...obj.x) - Math.min(...obj.x) + 1) * 16,
        height: (Math.max(...obj.y) - Math.min(...obj.y) + 1) * 16
      }

      return this.mouseX >= objRect.x &&
        this.mouseX <= objRect.x + objRect.width &&
        this.mouseY >= objRect.y &&
        this.mouseY <= objRect.y + objRect.height
    })
  },

  startObjectMove(event) {
    this.isDragging = true
    this.initialOffsets = []

    this.selectedObjects.forEach(obj => {
      const offsetX = this.mouseX - (obj.x[0] * 16)
      const offsetY = this.mouseY - (obj.y[0] * 16)

      this.initialOffsets.push({
        obj: obj,
        offsetX: offsetX,
        offsetY: offsetY
      })
    })

    this.lastMouseX = this.mouseX
    this.lastMouseY = this.mouseY
    this.clearSelectionBox()
  },

  changeToSelectModeAndStart(event) {
    this.changeMode('select')
    this.isDragging = true
    const rect = game.canvas.getBoundingClientRect()
    this.selectionStart = {
      x: (event.clientX - rect.left) / game.zoomLevel + camera.cameraX,
      y: (event.clientY - rect.top) / game.zoomLevel + camera.cameraY
    }
    this.selectionEnd = { ...this.selectionStart }
  },

  handleSelectionEnd(event) {
    if (game.editorMode === 'select') {
      this.isDragging = false
      this.updateSelectedObjects(event.shiftKey)
      this.clearSelectionBox()
      return true
    }

    if (game.editorMode === 'lasso') {
      this.isDragging = false
      this.updateSelectedObjectsWithLasso(event.shiftKey)
      this.clearLassoPath()
      return true
    }
    return false
  },

  finalizeObjectMovement() {
    this.isDragging = false
    if (this.selectedObjects.length > 0) {
      this.selectedObjects.forEach(obj => {
        obj.x = obj.x.map(coord => {
          const pixelCoordX = coord * 16
          const snappedX = Math.round(pixelCoordX) / 16
          return snappedX
        })
        obj.y = obj.y.map(coord => {
          const pixelCoordY = coord * 16
          const snappedY = Math.round(pixelCoordY) / 16
          return snappedY
        })
      })
      this.pushToUndoStack()
    }
  },

  handlePanningEnd(event) {
    if (event.button === 1 || game.editorMode === 'pan') {
      this.isPanning = false
      this.isDragging = false
      document.body.style.cursor = this.defaultCursor
      this.stopSlidingCamera()
      return true
    }
    return false
  },

  moveSelectedObjectsWithArrowKeys(direction) {
    if (this.selectedObjects.length === 0) {
      return
    }

    const step = this.isSnapEnabled ? 16 : 1
    let deltaX = 0, deltaY = 0
    switch (direction) {
      case 'ArrowUp':
        deltaY = -step
        break
      case 'ArrowDown':
        deltaY = step
        break
      case 'ArrowLeft':
        deltaX = -step
        break
      case 'ArrowRight':
        deltaX = step
        break
    }

    this.selectedObjects.forEach(obj => {
      obj.x = obj.x.map(coord => coord + deltaX / 16)
      obj.y = obj.y.map(coord => coord + deltaY / 16)
    })
  },

  updateMousePosition(event) {
    const rect = game.canvas.getBoundingClientRect()
    this.mouseX = (event.clientX - rect.left) / game.zoomLevel + camera.cameraX
    this.mouseY = (event.clientY - rect.top) / game.zoomLevel + camera.cameraY
  },

renderSelectedTiles() {
  this.selectedObjects = this.selectedObjects.filter(obj => {
    if (this.isObjectLocked(obj)) return false
    if (obj.visible === false) return false
    return true
  })
  if (this.selectedObjects.length === 0) return
  game.ctx.save()
  const animationSpeed = 300
  const markerLength = 4
  const lineWidth = 1
  const shadowOffset = 1
  const paddingFactor = 0.15
  const centerCircleRadius = 5
  game.ctx.lineWidth = lineWidth
  let globalMinX = Infinity, globalMinY = Infinity, globalMaxX = -Infinity, globalMaxY = -Infinity
  this.selectedObjects.forEach(obj => {
    const tileMinX = Math.min(...obj.x) * 16
    const tileMaxX = Math.max(...obj.x) * 16 + 16
    const tileMinY = Math.min(...obj.y) * 16
    const tileMaxY = Math.max(...obj.y) * 16 + 16
    const pivotX = (tileMinX + tileMaxX) / 2
    const pivotY = tileMaxY
    const scale = obj.scale || 1
    const widthScaled = (tileMaxX - tileMinX) * scale
    const heightScaled = (tileMaxY - tileMinY) * scale
    const objMinX = pivotX - widthScaled / 2
    const objMinY = pivotY - heightScaled
    const objMaxX = pivotX + widthScaled / 2
    const objMaxY = pivotY
    globalMinX = Math.min(globalMinX, objMinX)
    globalMinY = Math.min(globalMinY, objMinY)
    globalMaxX = Math.max(globalMaxX, objMaxX)
    globalMaxY = Math.max(globalMaxY, objMaxY)
  })
  const centerX = (globalMinX + globalMaxX) / 2
  const centerY = (globalMinY + globalMaxY) / 2
  if (!this.objectColors || this.objectColors.length !== this.selectedObjects.length) {
    const vibrantColors = [
      'rgb(255, 0, 0)', 'rgb(0, 255, 0)', 'rgb(0, 0, 255)',
      'rgb(255, 255, 0)', 'rgb(255, 0, 255)', 'rgb(0, 255, 255)',
      'rgb(255, 165, 0)', 'rgb(128, 0, 128)'
    ]
    this.objectColors = this.selectedObjects.map((_, index) => vibrantColors[index % vibrantColors.length])
  }
  this.selectedObjects.forEach((obj, index) => {
    const objectColor = this.objectColors[index]
    const tileMinX = Math.min(...obj.x) * 16
    const tileMaxX = Math.max(...obj.x) * 16 + 16
    const tileMinY = Math.min(...obj.y) * 16
    const tileMaxY = Math.max(...obj.y) * 16 + 16
    const pivotX = (tileMinX + tileMaxX) / 2
    const pivotY = tileMaxY
    const scale = obj.scale || 1
    const widthScaled = (tileMaxX - tileMinX) * scale
    const heightScaled = (tileMaxY - tileMinY) * scale
    const objMinX = pivotX - widthScaled / 2
    const objMinY = pivotY - heightScaled
    const objMaxX = pivotX + widthScaled / 2
    const objMaxY = pivotY
    const paddingX = widthScaled * paddingFactor
    const paddingY = heightScaled * paddingFactor
    const minObjX = objMinX + paddingX
    const minObjY = objMinY + paddingY
    const maxObjX = objMaxX - paddingX
    const maxObjY = objMaxY - paddingY
    const corners = [
      { x1: minObjX, y1: minObjY, x2: minObjX + markerLength, y2: minObjY, x3: minObjX, y3: minObjY + markerLength, dx: 1, dy: 1 },
      { x1: maxObjX, y1: minObjY, x2: maxObjX - markerLength, y2: minObjY, x3: maxObjX, y3: minObjY + markerLength, dx: -1, dy: 1 },
      { x1: minObjX, y1: maxObjY, x2: minObjX + markerLength, y2: maxObjY, x3: minObjX, y3: maxObjY - markerLength, dx: 1, dy: -1 },
      { x1: maxObjX, y1: maxObjY, x2: maxObjX - markerLength, y2: maxObjY, x3: maxObjX, y3: maxObjY - markerLength, dx: -1, dy: -1 }
    ]
    const timeOffset = performance.now() / animationSpeed
    const offset = Math.sin(timeOffset) * 2
    corners.forEach(corner => {
      const animatedX = corner.dx * offset
      const animatedY = corner.dy * offset
      game.ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)'
      game.ctx.beginPath()
      game.ctx.moveTo(corner.x1 + animatedX + shadowOffset, corner.y1 + animatedY + shadowOffset)
      game.ctx.lineTo(corner.x2 + animatedX + shadowOffset, corner.y2 + animatedY + shadowOffset)
      game.ctx.moveTo(corner.x1 + animatedX + shadowOffset, corner.y1 + animatedY + shadowOffset)
      game.ctx.lineTo(corner.x3 + animatedX + shadowOffset, corner.y3 + animatedY + shadowOffset)
      game.ctx.stroke()
      game.ctx.strokeStyle = objectColor
      game.ctx.beginPath()
      game.ctx.moveTo(corner.x1 + animatedX, corner.y1 + animatedY)
      game.ctx.lineTo(corner.x2 + animatedX, corner.y2 + animatedY)
      game.ctx.moveTo(corner.x1 + animatedX, corner.y1 + animatedY)
      game.ctx.lineTo(corner.x3 + animatedX, corner.y3 + animatedY)
      game.ctx.stroke()
    })
  })
  if (game.editorMode === 'move' && this.selectedObjects.length > 0) {
    game.ctx.beginPath()
    game.ctx.arc(centerX, centerY, centerCircleRadius, 0, Math.PI * 2)
    if (this.hoveredAxis === 'center' || this.dragStartAxis === 'center') {
      game.ctx.fillStyle = 'rgba(200, 200, 200, 0.8)'
      game.ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'
    } else {
      game.ctx.fillStyle = 'rgba(150, 150, 150, 0.5)'
      game.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'
    }
    game.ctx.fill()
    game.ctx.stroke()
  }
  game.ctx.restore()
},

  startObjectMove(event) {
    this.isDragging = true
    this.initialOffsets = []
    const axisClicked = this.checkAxisClick(event)
    if (axisClicked) {
      this.currentDragAxis = axisClicked
    } else {
      this.currentDragAxis = null
    }

    this.selectedObjects.forEach(obj => {
      this.initialOffsets.push({
        obj: obj,
        offsetX: this.mouseX - obj.x[0] * 16,
        offsetY: this.mouseY - obj.y[0] * 16
      })
    })

    this.lastMouseX = this.mouseX
    this.lastMouseY = this.mouseY
    this.clearSelectionBox()
  },

  checkAxisClick: function(event) {
    if (this.selectedObjects.length === 0) return null

    const obj = this.selectedObjects[0]
    const centerX = (Math.min(...obj.x) + Math.max(...obj.x)) / 2 * 16
    const bottomY = Math.max(...obj.y) * 16
    const axisLength = 30
    const clickRadius = 8
    const axes = {
      x: { dx: axisLength, dy: axisLength/2 },
      z: { dx: -axisLength, dy: axisLength/2 },
      y: { dx: 0, dy: -axisLength }
    }

    for (const [axis, vector] of Object.entries(axes)) {
      const endX = centerX + vector.dx
      const endY = bottomY + vector.dy
      const dist = this.pointToLineDistance(
        this.mouseX, this.mouseY,
        centerX, bottomY,
        endX, endY
      )
      if (dist < clickRadius) {
        return axis
      }
    }
    return null
  },

  pointToLineDistance: function(px, py, x1, y1, x2, y2) {
    const A = px - x1
    const B = py - y1
    const C = x2 - x1
    const D = y2 - y1

    const dot = A * C + B * D
    const lenSq = C * C + D * D
    let param = -1

    if (lenSq !== 0) {
      param = dot / lenSq
    }

    let xx, yy

    if (param < 0) {
      xx = x1
      yy = y1
    } else if (param > 1) {
      xx = x2
      yy = y2
    } else {
      xx = x1 + param * C
      yy = y1 + param * D
    }

    const dx = px - xx
    const dy = py - yy
    const distance = Math.sqrt(dx * dx + dy * dy)
    game.ctx.save()
    game.ctx.fillStyle = 'rgba(255, 0, 0, 0.3)'
    game.ctx.beginPath()
    game.ctx.arc(xx, yy, 2, 0, Math.PI * 2)
    game.ctx.fill()
    game.ctx.restore()

    return distance
  },

  isObjectLocked: function(obj) {
    const layerId = `item_${obj.layer_id}`
    const layerNode = editor_layers.findNodeById(layerId)
    return layerNode && layerNode.node.locked
  },

  isTopmostObject(obj, selectedObjects) {
    const objIndex = game.roomData.items.indexOf(obj)

    return selectedObjects.every(otherObj => {
      if (obj === otherObj) return true
      const otherIndex = game.roomData.items.indexOf(otherObj)

      if (otherIndex > objIndex) {
        const objRect = {
          x: Math.min(...obj.x) * 16,
          y: Math.min(...obj.y) * 16,
          width: (Math.max(...obj.x) - Math.min(...obj.x) + 1) * 16,
          height: (Math.max(...obj.y) - Math.min(...obj.y) + 1) * 16,
        }

        const otherRect = {
          x: Math.min(...otherObj.x) * 16,
          y: Math.min(...otherObj.y) * 16,
          width: (Math.max(...otherObj.x) - Math.min(...otherObj.x) + 1) * 16,
          height: (Math.max(...otherObj.y) - Math.min(...otherObj.y) + 1) * 16,
        }

        return !(
          objRect.x < otherRect.x + otherRect.width &&
          objRect.x + objRect.width > otherRect.x &&
          objRect.y < otherRect.y + otherRect.height &&
          objRect.y + objRect.height > otherRect.y
        )
      }
      return true
    })
  },

  renderSelectionBox() {
    if (this.isDragging) {
      const rect = {
        x: Math.min(this.selectionStart.x, this.selectionEnd.x),
        y: Math.min(this.selectionStart.y, this.selectionEnd.y),
        width: Math.abs(this.selectionEnd.x - this.selectionStart.x),
        height: Math.abs(this.selectionEnd.y - this.selectionStart.y)
      }
      game.ctx.save()
      game.ctx.fillStyle = 'rgba(255, 255, 255, 0.2)'
      game.ctx.fillRect(rect.x, rect.y, rect.width, rect.height)
      game.ctx.shadowColor = 'rgba(0, 0, 0, 0.5)'
      game.ctx.shadowBlur = 8
      game.ctx.shadowOffsetX = 4
      game.ctx.shadowOffsetY = 4
      const dashSpeed = performance.now() / 100
      game.ctx.lineDashOffset = -dashSpeed
      game.ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'
      game.ctx.lineWidth = 2
      game.ctx.setLineDash([6, 3])
      game.ctx.strokeRect(rect.x, rect.y, rect.width, rect.height)
      game.ctx.restore()
    }
  },

  renderLasso() {
    if (this.lassoPath.length > 1) {
      const dashSpeed = performance.now() / 100
      game.ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'
      game.ctx.lineWidth = 2
      game.ctx.setLineDash([6, 3])
      game.ctx.lineDashOffset = -dashSpeed
      game.ctx.beginPath()
      game.ctx.moveTo(this.lassoPath[0].x, this.lassoPath[0].y)

      for (let i = 1; i < this.lassoPath.length; i++) {
        game.ctx.lineTo(this.lassoPath[i].x, this.lassoPath[i].y)
      }

      game.ctx.stroke()
      game.ctx.setLineDash([])
      game.ctx.lineDashOffset = 0
    }
  },

  deleteSelectedObjects() {
  if (this.selectedObjects.length === 0) {
    return
  }
  this.pushToUndoStack()
  game.roomData.items = game.roomData.items.filter(item => {
    return !this.selectedObjects.includes(item)
  })
  this.selectedObjects.forEach(obj => {
    const iData = game.objectData[obj.id]
    if (iData && iData.length > 0) {
      const tileData = iData[0]
      if (tileData.l && Array.isArray(tileData.l)) {
        tileData.l.forEach((_, lightIndex) => {
          const lId = `${obj.layer_id}_light_${lightIndex}`
          lighting.lights = lighting.lights.filter(l => l.id !== lId)
        })
      }
    }
    const layerId = `item_${obj.layer_id}`
    editor_layers.removeLayerById(layerId)
  })
  this.selectedObjects = []
  editor_layers.selectLayersById([])
  if (this.previousMode === 'lasso') {
    this.changeMode('lasso')
  } else {
    this.changeMode('select')
  }
  },

  updateSelectedObjects(shiftKeyHeld, isClick = false, clickedCoords = null) {
  if (game.editorMode === 'pan') {
    return;
  }

  const isSingleClick = isClick || (
    this.selectionStart.x === this.selectionEnd.x &&
    this.selectionStart.y === this.selectionEnd.y
  );

  if (isSingleClick) {
    const clickedX = clickedCoords ? clickedCoords.x : this.selectionStart.x;
    const clickedY = clickedCoords ? clickedCoords.y : this.selectionStart.y;

    const affectedObjects = game.roomData.items.filter(roomItem => {
      if (this.isObjectLocked(roomItem)) return false;

      const xCoordinates = roomItem.x || [];
      const yCoordinates = roomItem.y || [];
      const itemBounds = {
        x: Math.min(...xCoordinates) * 16,
        y: Math.min(...yCoordinates) * 16,
        width: (Math.max(...xCoordinates) - Math.min(...xCoordinates) + 1) * 16,
        height: (Math.max(...yCoordinates) - Math.min(...yCoordinates) + 1) * 16
      };
      return (
        clickedX >= itemBounds.x &&
        clickedX < itemBounds.x + itemBounds.width &&
        clickedY >= itemBounds.y &&
        clickedY < itemBounds.y + itemBounds.height
      );
    });
    const topmostObject = affectedObjects.length > 0 ? affectedObjects[0] : null;

    if (topmostObject) {
      if (shiftKeyHeld) {
        const index = this.selectedObjects.indexOf(topmostObject);
        if (index === -1) {
          this.selectedObjects.push(topmostObject);
        } else {
          this.selectedObjects.splice(index, 1);
        }
      } else {
        this.selectedObjects = [topmostObject];
      }
    }
  } else {
    const selectionRect = {
      x: Math.min(this.selectionStart.x, this.selectionEnd.x),
      y: Math.min(this.selectionStart.y, this.selectionEnd.y),
      width: Math.abs(this.selectionEnd.x - this.selectionStart.x),
      height: Math.abs(this.selectionEnd.y - this.selectionStart.y)
    };
    const overlappingObjects = game.roomData.items.filter(item => {
      if (this.isObjectLocked(item)) return false;

      const itemRect = {
        x: Math.min(...item.x) * 16,
        y: Math.min(...item.y) * 16,
        width: (Math.max(...item.x) - Math.min(...item.x) + 1) * 16,
        height: (Math.max(...item.y) - Math.min(...item.y) + 1) * 16
      };

      return (
        itemRect.x < selectionRect.x + selectionRect.width &&
        itemRect.x + itemRect.width > selectionRect.x &&
        itemRect.y < selectionRect.y + selectionRect.height &&
        itemRect.y + itemRect.height > selectionRect.y
      );
    });

    if (shiftKeyHeld) {
      overlappingObjects.forEach(obj => {
        const index = this.selectedObjects.indexOf(obj);
        if (index === -1) {
          this.selectedObjects.push(obj);
        } else {
          this.selectedObjects.splice(index, 1);
        }
      });
    } else {
      this.selectedObjects = overlappingObjects;
    }
  }

  if (this.selectedObjects.length > 0) {
    this.changeMode('move');
  }

  const layerIds = this.selectedObjects.map(obj => "item_" + obj.layer_id);
  editor_layers.selectLayersById(layerIds);
  },

  renderObjectToCanvas(ctx, roomItem, tileData, xCoordinates, yCoordinates) {
    const tileSize = 16
    let frameData = tileData.i
    const isAnimated = Array.isArray(frameData[0][0])
    const currentFrame = tileData.currentFrame || 0

    if (isAnimated) {
      frameData = frameData[currentFrame % frameData.length]
    }

    const tileIndices = frameData.flatMap(entry => {
      if (typeof entry === 'string' && entry.includes('-')) {
        const [start, end] = entry.split('-').map(Number)
        return Array.from({ length: end - start + 1 }, (_, i) => start + i)
      }
      return entry
    })

    const gridWidth = tileData.a + 1
    const gridHeight = tileData.b + 1
    const topLeftX = Math.min(...xCoordinates) * tileSize
    const topLeftY = Math.min(...yCoordinates) * tileSize
    let currentIndex = 0

    for (let row = 0; row < gridHeight; row++) {
      for (let col = 0; col < gridWidth; col++) {
        const tileFrameIndex = tileIndices[currentIndex % tileIndices.length]
        currentIndex++
        const srcX = (tileFrameIndex % 150) * tileSize
        const srcY = Math.floor(tileFrameIndex / 150) * tileSize
        const posX = col * tileSize
        const posY = row * tileSize

        ctx.drawImage(
          assets.use(tileData.t),
          srcX, srcY, tileSize, tileSize,
          posX, posY, tileSize, tileSize
        )
      }
    }
  },

  updateSelectedObjectsWithLasso(shiftKeyHeld) {
    const affectedObjects = game.roomData.items.filter(item => {
      if (this.isObjectLocked(item)) return false

      const itemCenter = {
        x: (Math.min(...item.x) + Math.max(...item.x)) / 2 * 16,
        y: (Math.min(...item.y) + Math.max(...item.y)) / 2 * 16
      }
      return this.isPointInLasso(itemCenter)
    })

    if (shiftKeyHeld) {
      affectedObjects.forEach(obj => {
        const index = this.selectedObjects.indexOf(obj)
        if (index === -1) {
          this.selectedObjects.push(obj)
        } else {
          this.selectedObjects.splice(index, 1)
        }
      })
    } else {
      this.selectedObjects = affectedObjects
    }

    if (this.selectedObjects.length > 0) {
      this.changeMode('move')
    }

    const layerIds = this.selectedObjects.map(obj => "item_" + obj.layer_id)
    editor_layers.selectLayersById(layerIds)
  },

  isPointInLasso(point) {
    let inside = false
    const { x, y } = point

    for (let i = 0, j = this.lassoPath.length - 1; i < this.lassoPath.length; j = i++) {
      const xi = this.lassoPath[i].x, yi = this.lassoPath[i].y
      const xj = this.lassoPath[j].x, yj = this.lassoPath[j].y

      const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)
      if (intersect) inside = !inside
    }
    return inside
  },

  pushSelectedObjectsToTop() {
    if (this.selectedObjects.length === 0) {
      return
    }

    this.pushToUndoStack()
    const items = game.roomData.items

    this.selectedObjects.forEach(obj => {
      const index = items.indexOf(obj)
      if (index > -1) {
        items.splice(index, 1)
      }
    })

    items.push(...this.selectedObjects)
  },

  pushSelectedObjectsToBottom() {
    if (this.selectedObjects.length === 0) {
      return
    }

    this.pushToUndoStack()
    const items = game.roomData.items

    this.selectedObjects.forEach(obj => {
      const index = items.indexOf(obj)
      if (index > -1) {
        items.splice(index, 1)
      }
    })

    items.unshift(...this.selectedObjects)
  },

  spaceOutSelectedObjects() {
    if (this.selectedObjects.length <= 1) {
      return
    }

    const spacingDistance = 48

    let centerX = 0
    let centerY = 0

    this.selectedObjects.forEach(obj => {
      centerX += Math.min(...obj.x) * 16
      centerY += Math.min(...obj.y) * 16
    })

    centerX /= this.selectedObjects.length
    centerY /= this.selectedObjects.length

    this.selectedObjects.forEach((obj, index) => {
      const angle = (index / this.selectedObjects.length) * Math.PI * 2
      let newX = centerX + Math.cos(angle) * spacingDistance
      let newY = centerY + Math.sin(angle) * spacingDistance

      newX = Math.round(newX)
      newY = Math.round(newY)

      const offsetX = (newX / 16) - Math.min(...obj.x)
      const offsetY = (newY / 16) - Math.min(...obj.y)

      obj.x = obj.x.map(coord => Math.round(coord + offsetX))
      obj.y = obj.y.map(coord => Math.round(coord + offsetY))
    })
  },

  selectAllObjects() {
    this.selectedObjects = game.roomData.items.slice()
    if (this.selectedObjects.length > 0) {
      this.changeMode('move')
    }
  },

  copySelectedObjects() {
    if (this.selectedObjects.length > 0) {
      this.clipboard = this.selectedObjects.map(obj => JSON.parse(JSON.stringify(obj)))
    }
  },

  pasteCopiedObjects() {
    if (this.clipboard.length > 0) {
      const mouseX = this.mouseX
      const mouseY = this.mouseY
      const clipboardCenterX = this.clipboard.reduce((sum, obj) => sum + Math.min(...obj.x) * 16, 0) / this.clipboard.length
      const clipboardCenterY = this.clipboard.reduce((sum, obj) => sum + Math.min(...obj.y) * 16, 0) / this.clipboard.length
      const offsetX = mouseX - clipboardCenterX
      const offsetY = mouseY - clipboardCenterY
      const offsetForX = this.isSnapEnabled ? Math.floor(offsetX / 16) * 16 : Math.round(offsetX)
      const offsetForY = this.isSnapEnabled ? Math.floor(offsetY / 16) * 16 : Math.round(offsetY)

      const pastedObjects = this.clipboard.map(obj => {
        const newObj = JSON.parse(JSON.stringify(obj))
        const newLayerId = utils.generateId()
        newObj.layer_id = newLayerId

        newObj.x = newObj.x.map(coord => {
          const newCoordX = coord * 16 + offsetForX
          return this.isSnapEnabled ? Math.floor(newCoordX / 16) : newCoordX / 16
        })

        newObj.y = newObj.y.map(coord => {
          const newCoordY = coord * 16 + offsetForY
          return this.isSnapEnabled ? Math.floor(newCoordY / 16) : newCoordY / 16
        })

        editor_layers.addItemToLayer({
          layer_id: newLayerId,
          n: newObj.name || "Pasted Item"
        })

        return newObj
      })

      game.roomData.items.push(...pastedObjects)
      this.selectedObjects = pastedObjects
      const pastedLayerIds = pastedObjects.map(obj => "item_" + obj.layer_id)
      editor_layers.selectLayersById(pastedLayerIds)
      this.renderSelectedTiles()
      this.changeMode('move')
    }
  },

  undo() {
    if (this.undoStack.length === 0) {
      return
    }
    this.pushToRedoStack()
    const lastState = this.undoStack.pop()
    this.restoreRoomData(lastState)
  },

  redo() {
    if (this.redoStack.length === 0) {
      return
    }
    this.pushToUndoStack()
    const lastState = this.redoStack.pop()
    this.restoreRoomData(lastState)
  },

  saveRoomData() {
    fetch('/api/editor/scene/save', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        sceneid: game.sceneid,
        bg: game.sceneBg,
        roomData: game.roomData,
        editorLayers: editor_layers.layers
      }),
    })
    .then(async (response) => {
      if (!response.ok) {
        let errorData
        try {
          errorData = await response.json()
        } catch {
          errorData = { message: await response.text() }
        }
        throw new Error(errorData.message || 'Unknown error')
      }
      return response.json()
    })
    .then((result) => {
      plugin.close('editor_window')
      plugin.collision.createWalkableGrid()
    })
    .catch((error) => {
    })
  },

  revertToOriginalState() {
    if (this.originalRoomData) {
      game.roomData = JSON.parse(JSON.stringify(this.originalRoomData))
      plugin.collision.createWalkableGrid()
    }
  },

constrainCamera() {
  const margin = 1000;
  const scaledWindowWidth = window.innerWidth / game.zoomLevel;
  const scaledWindowHeight = window.innerHeight / game.zoomLevel;

  const minX = -margin / game.zoomLevel;
  const minY = -margin / game.zoomLevel;
  const maxX = (game.worldWidth - scaledWindowWidth) + margin / game.zoomLevel;
  const maxY = (game.worldHeight - scaledWindowHeight) + margin / game.zoomLevel;

  camera.cameraX = Math.max(minX, Math.min(camera.cameraX, maxX));
  camera.cameraY = Math.max(minY, Math.min(camera.cameraY, maxY));
},

panCameraToObject(obj) {
  if (!obj) return;
  
  const minX = Math.min(...obj.x) * 16;
  const maxX = Math.max(...obj.x) * 16 + 16;
  const minY = Math.min(...obj.y) * 16;
  const maxY = Math.max(...obj.y) * 16 + 16;
  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;
  const targetX = centerX - (window.innerWidth / game.zoomLevel / 2);
  const targetY = centerY - (window.innerHeight / game.zoomLevel / 2);
  
  camera.cameraX = targetX;
  camera.cameraY = targetY;
  
  this.constrainCamera();
},

  pushToUndoStack() {
    const currentState = JSON.parse(JSON.stringify(game.roomData))
    this.undoStack.push(currentState)
    this.redoStack = []
  },

  pushToRedoStack() {
    const currentState = JSON.parse(JSON.stringify(game.roomData))
    this.redoStack.push(currentState)
  },

  restoreRoomData(state) {
    if (!state) {
      return
    }
    try {
      game.roomData = JSON.parse(JSON.stringify(state))
      plugin.collision.createWalkableGrid()
    } catch (error) {
    }
  },

  clearSelectionBox() {
    this.selectionStart = { x: 0, y: 0 }
    this.selectionEnd = { x: 0, y: 0 }
  },

  clearLassoPath() {
    this.lassoPath = []
  },

  panCameraHorizontally: function(deltaY) {
    const scrollDirection = deltaY < 0 ? -1 : 1
    camera.cameraX += scrollDirection * 10
    this.constrainCamera()
  },

  isModeWithZoomOrMovement() {
    return ['select', 'lasso', 'move', 'zoom', 'delete'].includes(game.editorMode)
  },

  handleZoomOrMovement: function(deltaY, event) {
    camera.lerpEnabled = false
    camera.manual = true

    const rect = game.canvas.getBoundingClientRect()
    const mouseXBeforeZoom = (event.clientX - rect.left) / game.zoomLevel + camera.cameraX
    const mouseYBeforeZoom = (event.clientY - rect.top) / game.zoomLevel + camera.cameraY
    const zoomFactor = deltaY < 0 ? 1 : -1
    const newZoomLevel = Math.max(1, Math.min(game.zoomLevel + zoomFactor, 10))

    game.zoomLevel = newZoomLevel
    const mouseXAfterZoom = (event.clientX - rect.left) / game.zoomLevel + camera.cameraX
    const mouseYAfterZoom = (event.clientY - rect.top) / game.zoomLevel + camera.cameraY

    camera.cameraX += mouseXBeforeZoom - mouseXAfterZoom
    camera.cameraY += mouseYBeforeZoom - mouseYAfterZoom

    this.constrainCamera()
    game.resizeCanvas()
  },

  panCameraVertically: function(deltaY) {
    const scrollDirection = deltaY < 0 ? -1 : 1
    camera.cameraY += scrollDirection * 10
    this.constrainCamera()
  },

  zoomInBrushMode: function(deltaY, event) {
    const scrollDirection = deltaY < 0 ? 1 : -1
    const newZoomLevel = Math.max(2, Math.min(game.zoomLevel + scrollDirection, 10))

    const rect = game.canvas.getBoundingClientRect()
    const mouseXBeforeZoom = (event.clientX - rect.left) / game.zoomLevel + camera.cameraX
    const mouseYBeforeZoom = (event.clientY - rect.top) / game.zoomLevel + camera.cameraY

    game.zoomLevel = newZoomLevel
    const mouseXAfterZoom = (event.clientX - rect.left) / game.zoomLevel + camera.cameraX
    const mouseYAfterZoom = (event.clientY - rect.top) / game.zoomLevel + camera.cameraY

    camera.cameraX += mouseXBeforeZoom - mouseXAfterZoom
    camera.cameraY += mouseYBeforeZoom - mouseYAfterZoom

    this.constrainCamera()
  },

  findConnectedClusters() {
    const clusters = []
    const visited = new Set()

    this.selectedObjects.forEach(object => {
      if (!visited.has(object)) {
        const cluster = []
        this.dfsFindCluster(object, cluster, visited)
        clusters.push(cluster)
      }
    })
    return clusters
  },

  dfsFindCluster: function(object, cluster, visited) {
    visited.add(object)
    cluster.push(object)

    this.selectedObjects.forEach(otherObject => {
      if (!visited.has(otherObject) && this.areObjectsConnected(object, otherObject)) {
        this.dfsFindCluster(otherObject, cluster, visited)
      }
    })
  },

  areObjectsConnected: function(obj1, obj2) {
    const obj1MinX = Math.min(...obj1.x) * 16
    const obj1MinY = Math.min(...obj1.y) * 16
    const obj1MaxX = Math.max(...obj1.x) * 16 + 16
    const obj1MaxY = Math.max(...obj1.y) * 16 + 16
    const obj2MinX = Math.min(...obj2.x) * 16
    const obj2MinY = Math.min(...obj2.y) * 16
    const obj2MaxX = Math.max(...obj2.x) * 16 + 16
    const obj2MaxY = Math.max(...obj2.y) * 16 + 16
    const connected = obj1MaxX >= obj2MinX && obj1MinX <= obj2MaxX && obj1MaxY >= obj2MinY && obj1MinY <= obj2MaxY
    return connected
  },

handleKeyDown(event) {
  const key = event.key
  const activeElement = document.activeElement
  if (
    activeElement.tagName === 'INPUT' ||
    activeElement.tagName === 'TEXTAREA' ||
    activeElement.tagName === 'SELECT' ||
    activeElement.isContentEditable
  ) {
    return
  }

  if ((event.ctrlKey || event.metaKey) && event.key === 'a') {
    event.preventDefault()
    this.selectedObjects = [...game.roomData.items].filter(item => {
      const layerNode = editor_layers.findNodeById(`item_${item.layer_id}`)
      return layerNode && !layerNode.node.locked && layerNode.node.visible
    })
    this.changeMode('move')
    this.renderSelectedTiles()
    
    const allLayerIds = []
    const getAllLayerIds = (nodes) => {
      nodes.forEach(node => {
        if (!node.locked && node.visible) {
          allLayerIds.push(node.id)
          if (node.children && node.children.length > 0) {
            getAllLayerIds(node.children)
          }
        }
      })
    }
    getAllLayerIds(editor_layers.layers)
    editor_layers.selectLayersById(allLayerIds)
    return
  }

  switch (key) {
    case '1':
      this.changeMode('select')
      break
    case '3':
      this.changeMode('zoom')
      break
    case '4':
      this.changeMode('delete')
      break
    case '5':
      this.changeMode('pan')
      break
    case '6':
      this.changeMode('lasso')
      break
    case '7':
      this.changeMode('move')
      break
    default:
      break
  }

  if (key === 'Escape') {
    this.selectedObjects = []
    this.clearSelectionBox()
    this.clearLassoPath()
    this.changeMode('select')
    editor_layers.selectLayersById([])
  } else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(key)) {
    this.moveSelectedObjectsWithArrowKeys(key)
    event.preventDefault()
  } else if (key === 'Delete' || key === 'Backspace') {
    this.pushToUndoStack()
    this.selectedObjects.forEach(obj => {
      const layerId = `item_${obj.layer_id}`
      editor_layers.removeLayerById(layerId)
    })
    
    game.roomData.items = game.roomData.items.filter(item => 
      !this.selectedObjects.includes(item)
    )
    
    this.selectedObjects = []
    editor_layers.selectLayersById([])
    this.changeMode('select')
    this.renderSelectedTiles()
    event.preventDefault()
  }
},

  handleKeyUp(event) {
    const key = event.key
    const activeElement = document.activeElement
    if (
      activeElement.tagName === 'INPUT' ||
      activeElement.tagName === 'TEXTAREA' ||
      activeElement.tagName === 'SELECT' ||
      activeElement.isContentEditable
    ) {
      return
    }

    if (key === 'Shift' && (game.editorMode === 'select' || game.editorMode === 'lasso')) {
      this.changeMode('move')
    }
  },

  rotateObjects() {
    if (this.selectedObjects.length === 0) return
    this.pushToUndoStack()
    this.selectedObjects.forEach((obj) => {
      if (this.renderMode === 'isometric') {
        obj.flipHorizontal = !obj.flipHorizontal
      } else {
        const currentRotation = obj.rotation || 0
        obj.rotation = currentRotation + (Math.PI / 2)
      }
    })
  }
}
</script>
{% endif %}
