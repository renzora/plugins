<div id="layersPanel" class="fixed top-0 right-0 w-72 bg-gray-800 text-white rounded shadow-lg h-full flex flex-col transition-transform duration-300">
  <div id="slideTab" class="absolute -left-4 top-2 w-4 h-6 bg-gray-700 text-white flex items-center justify-center cursor-pointer rounded-l shadow-lg z-20">
    <svg id="slideTabIcon" xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
    </svg>
  </div>

  <div id="resizeHandle" class="resize-handle"></div>

  <div id="propertiesTitleBar" class="p-3 bg-gray-700 border-b border-gray-600 flex justify-between items-center cursor-pointer z-10">
    <span class="font-semibold">Properties</span>
    <svg
      id="propertiesToggleIcon"
      xmlns="http://www.w3.org/2000/svg"
      class="h-4 w-4 transition-transform duration-300"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
      stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
    </svg>
  </div>

  <div id="propertiesBody" class="p-4 flex flex-col bg-gray-800 transition-all duration-300">

  <label for="objectName" class="block text-sm font-medium text-gray-300">Scene Background</label>
<div class="relative">
  <input
    id="backgroundInput"
    type="text"
    class="w-full mt-1 p-2 text-black text-sm bg-gray-100 border border-gray-400 rounded focus:outline-none focus:ring-1 focus:ring-blue-500"
    placeholder="Type to search"
    autocomplete="off"
  />
  <button
    id="clearBackgroundBtn"
    class="hidden absolute right-2 top-1/2 -translate-y-1/2 bg-gray-600 text-gray-300 rounded w-6 h-6 flex items-center justify-center text-sm"
    type="button"
  >x</button>

  <div
    id="backgroundSuggestions"
    class="absolute w-full rounded border border-gray-700 hidden z-50 max-h-60 overflow-auto bg-gray-800"
  >
  </div>
</div>
</div>

<div id="transformTitleBar" class="p-3 bg-gray-700 border-b border-gray-600 flex justify-between items-center cursor-pointer z-10 hidden">
  <span class="font-semibold">Transform</span>
  <svg
    id="transformToggleIcon"
    xmlns="http://www.w3.org/2000/svg"
    class="h-4 w-4 transition-transform duration-300"
    fill="none"
    viewBox="0 0 24 24"
    stroke="currentColor"
    stroke-width="2">
    <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
  </svg>
</div>

<div id="transformBody" class="p-4 flex flex-col bg-gray-800 transition-all duration-300 hidden">
  <!-- Scale -->
  <div class="mb-4">
    <div class="flex items-center gap-2">
      <div class="text-sm font-medium text-gray-300">Scale</div>
      <div class="flex items-center gap-2 flex-1">
        <select
          id="scaleInput"
          class="w-20 p-1 text-black text-sm bg-gray-100 border border-gray-400 rounded focus:outline-none focus:ring-1 focus:ring-blue-500"
        >
          <option value="0.1">0.1x</option>
          <option value="0.2">0.2x</option>
          <option value="0.3">0.3x</option>
          <option value="0.4">0.4x</option>
          <option value="0.5">0.5x</option>
          <option value="0.6">0.6x</option>
          <option value="0.7">0.7x</option>
          <option value="0.8">0.8x</option>
          <option value="0.9">0.9x</option>
          <option value="1" selected>1.0x</option>
          <option value="1.1">1.1x</option>
          <option value="1.2">1.2x</option>
          <option value="1.3">1.3x</option>
          <option value="1.4">1.4x</option>
          <option value="1.5">1.5x</option>
          <option value="1.6">1.6x</option>
          <option value="1.7">1.7x</option>
          <option value="1.8">1.8x</option>
          <option value="1.9">1.9x</option>
          <option value="2.0">2.0x</option>
        </select>
        <input
          type="range"
          id="scaleSlider"
          class="flex-1 h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer accent-purple-500"
          min="0.1"
          max="2"
          step="0.1"
          value="1"
        />
      </div>
    </div>
  </div>

  <!-- Rotation -->
  <div class="mb-4">
    <div class="text-sm font-medium text-gray-300 mb-2">Rotation</div>
    <div class="flex items-center gap-2">
      <input
        type="number"
        id="rotationInput"
        class="w-20 p-1 text-black text-sm bg-gray-100 border border-gray-400 rounded focus:outline-none focus:ring-1 focus:ring-blue-500"
        step="45"
        value="0"
      />
      <input
        type="range"
        id="rotationSlider"
        class="flex-grow h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer accent-orange-500"
        min="0"
        max="360"
        step="45"
        value="0"
      />
      <button
        id="resetRotateBtn"
        class="px-2 py-1 bg-gray-600 text-xs text-gray-300 rounded hover:bg-gray-500"
      >Reset</button>
    </div>
  </div>

  <!-- Flip -->
  <div class="mb-4">
    <div class="text-sm font-medium text-gray-300 mb-2">Flip</div>
    <div class="flex items-center gap-2">
      <button
        id="flipHBtn"
        class="px-2 py-1 bg-gray-600 text-xs text-gray-300 rounded hover:bg-gray-500"
        title="Flip Horizontally"
      >Horizontal</button>
      <button
        id="flipVBtn"
        class="px-2 py-1 bg-gray-600 text-xs text-gray-300 rounded hover:bg-gray-500"
        title="Flip Vertically"
      >Vertical</button>
    </div>
  </div>
</div>

<div id="spectrumTitleBar" class="p-3 bg-gray-700 border-b border-gray-600 flex justify-between items-center cursor-pointer z-10 hidden">
  <span class="font-semibold">Color Spectrum</span>
  <svg
    id="spectrumToggleIcon"
    xmlns="http://www.w3.org/2000/svg"
    class="h-4 w-4 transition-transform duration-300"
    fill="none"
    viewBox="0 0 24 24"
    stroke="currentColor"
    stroke-width="2">
    <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
  </svg>
</div>

<div id="spectrumBody" class="p-4 flex flex-col bg-gray-800 transition-all duration-300 hidden">
  <div class="spectrum-container h-32 mb-4 relative">
    <div class="absolute inset-0 rounded" style="background: linear-gradient(to right, 
      hsl(0, 100%, 50%),
      hsl(60, 100%, 50%),
      hsl(120, 100%, 50%),
      hsl(180, 100%, 50%),
      hsl(240, 100%, 50%),
      hsl(300, 100%, 50%),
      hsl(360, 100%, 50%))">
    </div>
    <div class="absolute inset-0 rounded" style="background: linear-gradient(to bottom,
      rgba(0,0,0,0),
      rgba(0,0,0,1)),
      linear-gradient(to right,
      rgba(255,255,255,1),
      rgba(255,255,255,0))">
    </div>
    <div id="spectrumHandle" class="absolute w-4 h-4 border-2 border-white rounded-full shadow-lg cursor-pointer" style="transform: translate(-50%, -50%)"></div>
  </div>
  <div class="flex gap-2 items-center">
    <div id="selectedColorPreview" class="w-8 h-8 rounded border border-gray-600"></div>
    <input type="text" id="colorHexInput" class="bg-gray-700 text-sm px-2 py-1 rounded border border-gray-600" value="#000000">
  </div>
</div>

<div id="nodesTitleBar" class="p-3 bg-gray-700 border-b border-gray-600 flex justify-between items-center cursor-pointer z-10 hidden">
  <span class="font-semibold">Object Addons</span>
  <svg
    id="nodesToggleIcon"
    xmlns="http://www.w3.org/2000/svg"
    class="h-4 w-4 transition-transform duration-300"
    fill="none"
    viewBox="0 0 24 24"
    stroke="currentColor"
    stroke-width="2">
    <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
  </svg>
</div>

<div id="nodesBody" class="flex flex-col bg-gray-800 transition-all duration-300 hidden">
  <div class="border-b border-gray-600">
    <div class="relative">
      <input
        type="text"
        id="nodeSearch"
        placeholder="Search nodes..."
        class="w-full bg-gray-700 text-white text-sm px-3 py-2 pl-8 focus:outline-none"
      />
      <svg
        xmlns="http://www.w3.org/2000/svg"
        class="h-4 w-4 absolute left-2 top-1/2 transform -translate-y-1/2 text-gray-400"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
      </svg>
    </div>
  </div>
  <div id="nodesList" class="h-64 overflow-y-auto">
    <div class="node-list-container">
    </div>
  </div>
</div>

<div id="layersTitleBar" class="p-3 bg-gray-700 border-b border-gray-600 flex justify-between items-center cursor-pointer z-10">
  <span class="font-semibold">Layers</span>
  <svg
    id="layersToggleIcon"
    xmlns="http://www.w3.org/2000/svg"
    class="h-4 w-4 transition-transform duration-300"
    fill="none"
    viewBox="0 0 24 24"
    stroke="currentColor"
    stroke-width="2">
    <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
  </svg>
</div>

<div class="border-b border-gray-600">
  <div class="relative">
    <input
      type="text"
      id="layerSearch"
      placeholder="Search layers..."
      class="w-full bg-gray-700 text-white text-sm px-3 py-2 pl-8 pr-8 focus:outline-none"
    />
    <svg
      xmlns="http://www.w3.org/2000/svg"
      class="h-4 w-4 absolute left-2 top-1/2 transform -translate-y-1/2 text-gray-400"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
    </svg>
    <button
      id="clearLayerSearchBtn"
      class="hidden absolute right-2 top-1/2 -translate-y-1/2 bg-gray-600 text-gray-300 rounded w-6 h-6 flex items-center justify-center text-sm"
      type="button"
    >x</button>
  </div>
</div>

  <div id="layersBody" class="flex flex-col flex-grow overflow-y-auto transition-all duration-300">
    <div id="layersList" class="flex flex-col mt-1 relative"></div>
  </div>

<div class="p-2 bg-gray-700 border-t border-gray-600 flex justify-center">
  <div class="flex gap-12">
    <div class="flex gap-3">
      <button id="addLayerBtn" class="hint--top px-3 py-2 bg-gray-800 hover:bg-gray-900 text-gray-300 hover:text-white text-sm flex items-center gap-2 rounded-md transition-colors duration-150 shadow-sm border border-gray-700" aria-label="New Layer">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
          <path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" />
        </svg>
      </button>

      <button id="addGroupBtn" class="hint--top px-3 py-2 bg-gray-800 hover:bg-gray-900 text-gray-300 hover:text-white text-sm flex items-center gap-2 rounded-md transition-colors duration-150 shadow-sm border border-gray-700" aria-label="New Group">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none"
             stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 21V8a2 2 0 0 0-2-2H7v15a2 2 0 0 0 2 2h10" />
          <path d="M3 21V3h13a2 2 0 0 1 2 2v2" />
        </svg>
      </button>
    </div>

    <div class="flex gap-3">
      <button id="expandAllBtn" class="hint--top px-3 py-2 bg-gray-800 hover:bg-gray-900 text-gray-300 hover:text-white text-sm flex items-center gap-2 rounded-md transition-colors duration-150 shadow-sm border border-gray-700" aria-label="Expand All">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none" 
             stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M7 8l5 5 5-5"/>
          <path d="M7 13l5 5 5-5"/>
        </svg>
      </button>

      <button id="collapseAllBtn" class="hint--top px-3 py-2 bg-gray-800 hover:bg-gray-900 text-gray-300 hover:text-white text-sm flex items-center gap-2 rounded-md transition-colors duration-150 shadow-sm border border-gray-700" aria-label="Collapse All">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none"
             stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M7 15l5-5 5 5"/>
          <path d="M7 10l5-5 5 5"/>
        </svg>
      </button>
      
      <button id="toggleLockAllBtn" class="hint--top px-3 py-2 bg-gray-800 hover:bg-gray-900 text-gray-300 hover:text-white text-sm flex items-center gap-2 rounded-md transition-colors duration-150 shadow-sm border border-gray-700" aria-label="Toggle Lock">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none" 
             stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <rect x="3" y="11" width="18" height="11" rx="2" ry="2" />
          <path d="M7 11V7a5 5 0 0 1 10 0v4" />
        </svg>
      </button>
    </div>
  </div>
</div>
</div>

<style>
  .node-container {
    display: flex;
    flex-direction: column;
  }
  .layer-item {
    position: relative;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.25rem;
    background-color: #374151;
    border: 1px solid #4b5563;
    transition: background-color 0.2s, color 0.2s;
  }
  .selected {
    background-color: #3b82f6;
    color: #ffffff;
  }
  .icon-btn {
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 1.25rem;
    height: 1.25rem;
  }
  .layer-name {
    flex-grow: 1;
    font-size: 0.875rem;
    text-align: left;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .edit-layer-name {
    background: #ffffff !important;
    border: none;
    border-bottom: 1px solid #6b7280;
    width: 100%;
    font-size: 0.875rem;
    outline: none;
    color: #000000;
    padding: 0;
    box-sizing: border-box;
  }
  .children-container {
    margin-left: 1.25rem; 
    display: flex;
    flex-direction: column;
    gap: 0;
    transition: all 0.3s ease-in-out;
  }
  .collapsed {
    display: none;
  }
  .hidden-panel {
    max-height: 0 !important;
    padding-top: 0 !important;
    padding-bottom: 0 !important;
  }
  .drop-indicator {
    position: absolute;
    left: 0;
    right: 0;
    height: 2px;
    background-color: #60a5fa;
    z-index: 9999;
    pointer-events: none;
    display: none;
  }
  .drag-container {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    z-index: 9999;
    overflow: hidden;
  }
  .dragging-clone {
    position: absolute;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    cursor: grabbing;
    background: #fff; 
    color: #000;
    padding: 0.25rem 0.5rem;
    border: 1px dashed #ccc;
    border-radius: 4px;
    font-size: 0.875rem;
  }
  .pending-drag {
    outline: 1px dashed #ccc;
  }
  .layer-item[data-type="layer"] {
    border-left: 4px solid #3b82f6;
  }
  .layer-item[data-type="group"] {
    border-left: 4px solid #10b981;
  }
  .layer-item[data-type="item"] {
    border-left: 4px solid #f59e0b;
  }
  #resizeHandle {
    position: absolute;
    left: -5px;
    top: 0;
    bottom: 0;
    width: 10px;
    cursor: ew-resize;
    z-index: 10;
  }
  #resizeHandle:hover {
    background: rgba(255, 255, 255, 0.1);
  }
  #backgroundSuggestions {
    top: calc(100% + 0.5rem) !important;
    left: 0;
  }
  #backgroundSuggestions::before {
    content: "";
    position: absolute;
    top: -10px;
    left: 1.5rem;
    border-left: 10px solid transparent;
    border-right: 10px solid transparent;
    border-bottom: 10px solid #1f2937;
  }
  #backgroundSuggestions div:hover {
    background-color: #2563eb;
    color: #ffffff;
  }
  #backgroundSuggestions {
    max-height: 16rem;
    border-color: #2563eb;
  }
  .slid-off {
    transform: translateX(100%);
  }
</style>

<script>
editor_layers = {
  needsUpdate: true,
  nodesPanelOpen: true,
  spectrumPanelOpen: true,
  propertiesPanelOpen: true,
  transformPanelOpen: true,
  layers: [],
  activeLayerId: "layer_default",
  selectedLayers: new Set(),
  lastClickedId: null,
  panelOpen: true,
  dragCandidate: false,
  isDragging: false,
  dragStartX: 0,
  dragStartY: 0,
  dragThreshold: 5,
  draggedNodes: [],
  draggedEl: null,
  draggedClone: null,
  offsetX: 0,
  offsetY: 0,
  dropPosition: null,
  dropIndicator: null,
  dragContainer: null,
  searchTerm: '',
  filteredLayers: null,
  nodeCategories: {
    'Input': [
      { id: 'number', name: 'Number', color: '#3B82F6', icon: 'hash' },
      { id: 'string', name: 'String', color: '#3B82F6', icon: 'type' },
      { id: 'boolean', name: 'Boolean', color: '#3B82F6', icon: 'toggle-left' },
      { id: 'vector2', name: 'Vector2', color: '#3B82F6', icon: 'move' },
      { id: 'color', name: 'Color', color: '#3B82F6', icon: 'droplet' }
    ],
    'Math': [
      { id: 'add', name: 'Add', color: '#10B981', icon: 'plus' },
      { id: 'subtract', name: 'Subtract', color: '#10B981', icon: 'minus' },
      { id: 'multiply', name: 'Multiply', color: '#10B981', icon: 'x' },
      { id: 'divide', name: 'Divide', color: '#10B981', icon: 'divide' },
      { id: 'modulo', name: 'Modulo', color: '#10B981', icon: 'percent' },
      { id: 'sin', name: 'Sine', color: '#10B981', icon: 'trending-up' },
      { id: 'cos', name: 'Cosine', color: '#10B981', icon: 'trending-up' },
      { id: 'pow', name: 'Power', color: '#10B981', icon: 'chevrons-up' }
    ],
  },
  filteredNodes: null,
  panelSlideVisible: true,

initUI() {
    const addLayerBtn = document.getElementById("addLayerBtn");
    const addGroupBtn = document.getElementById("addGroupBtn");
    const layersTitleBar = document.getElementById("layersTitleBar");
    const nodesTitleBar = document.getElementById("nodesTitleBar");
    const spectrumTitleBar = document.getElementById("spectrumTitleBar");
    const propertiesTitleBar = document.getElementById("propertiesTitleBar");
    const transformTitleBar = document.getElementById("transformTitleBar");
    
    nodesTitleBar.addEventListener("click", () => this.toggleNodesPanel());
    spectrumTitleBar.addEventListener("click", () => this.toggleSpectrumPanel());
    propertiesTitleBar.addEventListener("click", () => this.togglePropertiesPanel());
    transformTitleBar.addEventListener("click", () => this.toggleTransformPanel());
    
    const searchInput = document.getElementById('nodeSearch');
    searchInput.addEventListener('input', (e) => this.handleNodeSearch(e.target.value));
    
    const layerSearch = document.getElementById('layerSearch');
    const clearLayerSearchBtn = document.getElementById('clearLayerSearchBtn');

    layerSearch.addEventListener('input', (e) => this.handleLayerSearch(e.target.value));

    clearLayerSearchBtn.addEventListener('click', () => {
        layerSearch.value = '';
        this.handleLayerSearch('');
        layerSearch.focus();
    });
    
    const expandAllBtn = document.getElementById("expandAllBtn");
    const collapseAllBtn = document.getElementById("collapseAllBtn");
    const toggleLockAllBtn = document.getElementById("toggleLockAllBtn");

    expandAllBtn.addEventListener("click", () => this.expandAll());
    collapseAllBtn.addEventListener("click", () => this.collapseAll());
    toggleLockAllBtn.addEventListener("click", () => this.toggleLockAll());
    
    addLayerBtn.addEventListener("click", () => this.addLayer());
    addGroupBtn.addEventListener("click", () => this.addGroup());
    layersTitleBar.addEventListener("click", () => this.toggleLayersPanel());
    
    this.dropIndicator = document.createElement("div");
    this.dropIndicator.className = "drop-indicator";
    const layersList = document.getElementById("layersList");
    layersList.appendChild(this.dropIndicator);
    
    this.dragContainer = document.createElement("div");
    this.dragContainer.className = "drag-container";
    layersList.appendChild(this.dragContainer);
    
    document.addEventListener("mousemove", (e) => this.handleMouseMove(e));
    document.addEventListener("mouseup", (e) => this.handleMouseUp(e));
    
    const layersPanel = document.getElementById("layersPanel");
    const resizeHandle = document.getElementById("resizeHandle");
    let isResizing = false;
    
    resizeHandle.addEventListener("mousedown", (e) => {
        isResizing = true;
        document.body.style.cursor = "ew-resize";
    });
    
    document.addEventListener("mousemove", (e) => {
        if (!isResizing) return;
        const panelRect = layersPanel.getBoundingClientRect();
        const newWidth = window.innerWidth - e.clientX;
        if (newWidth >= 200 && newWidth <= 600) {
            layersPanel.style.width = `${newWidth}px`;
        }
    });
    
    document.addEventListener("mouseup", () => {
        if (isResizing) {
            isResizing = false;
            document.body.style.cursor = "";
        }
    });
    
    this.initBackgroundInput();
    
    const slideTab = document.getElementById("slideTab");
    slideTab.addEventListener("click", () => this.togglePanelSlide());
},

initTransformControls() {
  const scaleInput = document.getElementById('scaleInput');
  const scaleSlider = document.getElementById('scaleSlider');
  const rotationInput = document.getElementById('rotationInput');
  const rotationSlider = document.getElementById('rotationSlider');
  const flipHBtn = document.getElementById('flipHBtn');
  const flipVBtn = document.getElementById('flipVBtn');
  const resetRotateBtn = document.getElementById('resetRotateBtn');

  const updateScale = (value) => {
    if (!editor_window.selectedObjects.length) return;
    editor_window.pushToUndoStack();
    const scale = parseFloat(value);
    scaleInput.value = scale;
    scaleSlider.value = scale;
    editor_window.selectedObjects.forEach(obj => {
      obj.scale = scale;
    });
  };

  const updateRotation = (value) => {
    if (!editor_window.selectedObjects.length) return;
    editor_window.pushToUndoStack();
    editor_window.selectedObjects.forEach(obj => {
      obj.rotation = (parseFloat(value) * Math.PI) / 180;
    });
  };

  scaleInput.addEventListener('change', (e) => {
    updateScale(e.target.value);
  });

  scaleSlider.addEventListener('input', (e) => {
    updateScale(e.target.value);
  });

  rotationInput.addEventListener('input', (e) => {
    const value = e.target.value;
    rotationSlider.value = value;
    updateRotation(value);
  });

  rotationSlider.addEventListener('input', (e) => {
    const value = e.target.value;
    rotationInput.value = value;
    updateRotation(value);
  });

  flipHBtn.addEventListener('click', () => {
    if (!editor_window.selectedObjects.length) return;
    editor_window.pushToUndoStack();
    editor_window.selectedObjects.forEach(obj => {
      obj.flipHorizontal = !obj.flipHorizontal;
    });
  });

  flipVBtn.addEventListener('click', () => {
    if (!editor_window.selectedObjects.length) return;
    editor_window.pushToUndoStack();
    editor_window.selectedObjects.forEach(obj => {
      obj.flipVertical = !obj.flipVertical;
    });
  });

  resetRotateBtn.addEventListener('click', () => {
    if (!editor_window.selectedObjects.length) return;
    rotationInput.value = 0;
    rotationSlider.value = 0;
    updateRotation(0);
  });
},

updateTransformControls() {
  const transformTitleBar = document.getElementById('transformTitleBar');
  const transformBody = document.getElementById('transformBody');
  const scaleInput = document.getElementById('scaleInput');
  const scaleSlider = document.getElementById('scaleSlider');
  const rotationInput = document.getElementById('rotationInput');
  const rotationSlider = document.getElementById('rotationSlider');
  const flipHBtn = document.getElementById('flipHBtn');
  const flipVBtn = document.getElementById('flipVBtn');

  if (editor_window.selectedObjects.length > 0) {
    transformTitleBar.classList.remove('hidden');
    if (this.transformPanelOpen) {
      transformBody.classList.remove('hidden');
    }
  } else {
    transformTitleBar.classList.add('hidden');
    transformBody.classList.add('hidden');
  }

  if (editor_window.selectedObjects.length === 1) {
    const obj = editor_window.selectedObjects[0];
    const scale = obj.scale || 1;
    scaleInput.value = scale;
    scaleSlider.value = scale;
    const rotation = obj.rotation || 0;
    const degrees = (rotation * 180) / Math.PI;
    rotationInput.value = degrees;
    rotationSlider.value = degrees;
    flipHBtn.classList.toggle('bg-blue-500', obj.flipHorizontal);
    flipVBtn.classList.toggle('bg-blue-500', obj.flipVertical);
  } else if (editor_window.selectedObjects.length > 1) {
    scaleInput.value = 1;
    scaleSlider.value = 1;
    rotationInput.value = 0;
    rotationSlider.value = 0;
    flipHBtn.classList.remove('bg-blue-500');
    flipVBtn.classList.remove('bg-blue-500');
  }
},

toggleTransformPanel() {
  const bodyEl = document.getElementById("transformBody");
  const toggleIcon = document.getElementById("transformToggleIcon");
  this.transformPanelOpen = !this.transformPanelOpen;
  if (this.transformPanelOpen) {
    bodyEl.classList.remove("hidden-panel");
    toggleIcon.classList.remove("rotate-180");
  } else {
    bodyEl.classList.add("hidden-panel");
    toggleIcon.classList.add("rotate-180");
  }
},

start() {
  this.fetchSceneLayers(game.sceneid).then(() => {
    this.initUI();
    this.initTransformControls();
    if (!this.layers || this.layers.length === 0) {
      this.layers = [{
        id: "layer_default",
        type: "layer",
        name: "Default Layer",
        visible: true,
        locked: false,
        expanded: true,
        children: []
      }];
    }
    this.activeLayerId = this.layers[0].id;
    this.selectLayersById(this.activeLayerId);
    this.renderAllLayers();
    this.initColorPicker();
  });
},

initBackgroundInput() {
  const bgInput = document.getElementById('backgroundInput');
  const suggestionsEl = document.getElementById('backgroundSuggestions');
  const clearBtn = document.getElementById('clearBackgroundBtn');
  bgInput.setAttribute('autocomplete', 'off');

  clearBtn.addEventListener('click', () => {
    game.sceneBg = null;
    if (game.roomData) {
      game.roomData.bg = null;
    }
    game.buildRepeatingBackground();
    game.resizeCanvas();
    bgInput.value = '';
    suggestionsEl.classList.add('hidden');
    clearBtn.classList.add('hidden');
    bgInput.focus();
  });

  if (game.sceneBg) {
    const objectData = assets.use('objectData') || game.objectData;
    if (objectData && objectData[game.sceneBg] && objectData[game.sceneBg][0]) {
      bgInput.value = objectData[game.sceneBg][0].n || '';
      clearBtn.classList.remove('hidden');
    }
  }

  bgInput.addEventListener('input', () => {
    const val = bgInput.value.trim();
    if (val === '') {
      clearBtn.classList.add('hidden');
      suggestionsEl.classList.add('hidden');
      suggestionsEl.innerHTML = '';
      return;
    } else {
      clearBtn.classList.remove('hidden');
    }
    
    const objectData = assets.use('objectData') || game.objectData;
    if (!objectData) return;
    
    const singleTileEntries = [];
    for (const [key, objArr] of Object.entries(objectData)) {
      if (!Array.isArray(objArr)) continue;
      objArr.forEach(obj => {
        const tileIndices = obj.i;
        let singleTile = false;
        
        if (typeof tileIndices === 'number') {
          singleTile = true;
        } else if (Array.isArray(tileIndices)) {
          if (tileIndices.length === 1) {
            const tileVal = tileIndices[0];
            if (typeof tileVal === 'number' || 
               (typeof tileVal === 'string' && !tileVal.includes('-'))) {
              singleTile = true;
            }
          }
        } else if (typeof tileIndices === 'string' && !tileIndices.includes('-')) {
          singleTile = true;
        }
        
        if (singleTile) {
          singleTileEntries.push({ 
            key, 
            name: obj.n || key,
            data: obj,
            tileIndex: typeof tileIndices === 'number' ? tileIndices : 
                      Array.isArray(tileIndices) ? tileIndices[0] : 
                      parseInt(tileIndices)
          });
        }
      });
    }
    
    const query = val.toLowerCase();
    const filtered = singleTileEntries.filter(entry =>
      entry.name.toLowerCase().includes(query)
    );
    
    suggestionsEl.innerHTML = '';
    if (!filtered.length) {
      suggestionsEl.classList.add('hidden');
      return;
    }
    
    suggestionsEl.classList.remove('hidden');
    filtered.forEach(entry => {
      const div = document.createElement('div');
      div.textContent = entry.name;
      div.className = 'px-2 py-1 cursor-pointer';
      div.addEventListener('click', () => {
        bgInput.value = entry.name;
        
        game.sceneBg = entry.key;
        if (game.roomData) {
          game.roomData.bg = entry.key;
        }
        
        game.buildRepeatingBackground();
        game.resizeCanvas();
        
        suggestionsEl.classList.add('hidden');
        clearBtn.classList.remove('hidden');
      });
      suggestionsEl.appendChild(div);
    });
  });

  bgInput.addEventListener('blur', () => {
    setTimeout(() => {
      suggestionsEl.classList.add('hidden');
    }, 200);
  });

  bgInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
    }
  });
},

  initColorPicker: function() {
    const spectrumContainer = document.querySelector(".spectrum-container");
    const spectrumHandle = document.getElementById("spectrumHandle");
    const colorHexInput = document.getElementById("colorHexInput");
    const selectedColorPreview = document.getElementById("selectedColorPreview");
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    let isDragging = false;
    let containerRect;
    const buildSpectrumCanvas = () => {
      containerRect = spectrumContainer.getBoundingClientRect();
      canvas.width = containerRect.width;
      canvas.height = containerRect.height;
      const rainbow = ctx.createLinearGradient(0, 0, canvas.width, 0);
      rainbow.addColorStop(0,   "hsl(0, 100%, 50%)");
      rainbow.addColorStop(0.2, "hsl(60, 100%, 50%)");
      rainbow.addColorStop(0.4, "hsl(120, 100%, 50%)");
      rainbow.addColorStop(0.6, "hsl(180, 100%, 50%)");
      rainbow.addColorStop(0.8, "hsl(240, 100%, 50%)");
      rainbow.addColorStop(1,   "hsl(360,100%, 50%)");
      ctx.fillStyle = rainbow;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      const blackGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      blackGradient.addColorStop(0, "rgba(0,0,0,0)");
      blackGradient.addColorStop(1, "rgba(0,0,0,1)");
      ctx.fillStyle = blackGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      const whiteGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
      whiteGradient.addColorStop(0, "rgba(255,255,255,1)");
      whiteGradient.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = whiteGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    };
    const rgbToHex = (r, g, b) => {
      return "#" + [r, g, b].map(x => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      }).join("");
    };
    const updateColorFromPosition = (clientX, clientY) => {
      let x = clientX - containerRect.left;
      let y = clientY - containerRect.top;
      if (x < 0) x = 0;
      if (x > containerRect.width) x = containerRect.width;
      if (y < 0) y = 0;
      if (y > containerRect.height) y = containerRect.height;
      spectrumHandle.style.left = x + "px";
      spectrumHandle.style.top = y + "px";
      const pixel = ctx.getImageData(x, y, 1, 1).data;
      const [r, g, b] = pixel;
      const hex = rgbToHex(r, g, b);
      colorHexInput.value = hex;
      selectedColorPreview.style.backgroundColor = hex;
    };
    const pointerDown = (e) => {
      isDragging = true;
      buildSpectrumCanvas();
      updateColorFromPosition(e.clientX, e.clientY);
    };
    const pointerMove = (e) => {
      if (!isDragging) return;
      updateColorFromPosition(e.clientX, e.clientY);
    };
    const pointerUp = () => {
      isDragging = false;
    };
    spectrumContainer.addEventListener("mousedown", pointerDown);
    spectrumHandle.addEventListener("mousedown", (e) => {
      e.stopPropagation();
      pointerDown(e);
    });
    document.addEventListener("mousemove", pointerMove);
    document.addEventListener("mouseup", pointerUp);
    colorHexInput.addEventListener("change", (e) => {
      const val = e.target.value.trim();
      selectedColorPreview.style.backgroundColor = val;
    });
  },

  fetchSceneLayers: async function(sceneId) {
    try {
      const response = await fetch(`/api/editor/scene/${sceneId}`);
      if (!response.ok) throw new Error('Failed to load scene data.');
      const sceneData = await response.json();
      if (sceneData && sceneData.editorLayers) {
        this.layers = sceneData.editorLayers;
      } else {
        this.layers = [{
          id: "layer_default",
          type: "layer",
          name: "Default Layer",
          visible: true,
          locked: false,
          expanded: true,
          children: []
        }];
      }
    } catch (err) {
      this.layers = [{
        id: "layer_default",
        type: "layer",
        name: "Default Layer",
        visible: true,
        locked: false,
        expanded: true,
        children: []
      }];
    }
  },

  addLayer() {
    const selectedNodes = this.getSelectedNodes();
    let newLayer;
    if (selectedNodes.length === 0) {
      newLayer = {
        id: `layer_${Date.now()}`,
        type: "layer",
        name: "New Layer",
        visible: true,
        locked: false,
        expanded: true,
        children: []
      };
      this.layers.unshift(newLayer);
      this.selectedLayers.clear();
      this.selectedLayers.add(newLayer.id);
      this.activeLayerId = newLayer.id;
      this.lastClickedId = newLayer.id;
      this.renderAllLayers();
      setTimeout(() => this.editLayerName(newLayer.id), 0);
      return;
    }
    let topmostNode = selectedNodes[0];
    let topmostParentInfo = this.findParentNodeById(topmostNode.id);
    let insertIndex = 0;
    if (topmostParentInfo) {
      insertIndex = topmostParentInfo.node.children.indexOf(topmostNode);
    } else {
      insertIndex = this.layers.indexOf(topmostNode);
    }
    newLayer = {
      id: `layer_${Date.now()}`,
      type: "layer",
      name: "New Layer",
      visible: true,
      locked: false,
      expanded: true,
      children: []
    };
    selectedNodes.forEach(node => {
      this.removeNodeFromParent(node.id);
      newLayer.children.push(node);
    });
    if (topmostParentInfo) {
      topmostParentInfo.node.children.splice(insertIndex, 0, newLayer);
    } else {
      this.layers.splice(insertIndex, 0, newLayer);
    }
    this.selectedLayers.clear();
    this.selectedLayers.add(newLayer.id);
    this.activeLayerId = newLayer.id;
    this.lastClickedId = newLayer.id;
    this.renderAllLayers();
    setTimeout(() => this.editLayerName(newLayer.id), 0);
    this.refreshLayerView();
  },

  addGroup() {
    const selectedNodes = this.getSelectedNodes();
    let newGroup;
    if (selectedNodes.length === 0) {
      newGroup = {
        id: `group_${Date.now()}`,
        type: "group",
        name: "New Group",
        visible: true,
        locked: false,
        expanded: true,
        children: []
      };
      this.layers.unshift(newGroup);
      this.selectedLayers.clear();
      this.selectedLayers.add(newGroup.id);
      this.activeLayerId = newGroup.id;
      this.lastClickedId = newGroup.id;
      this.renderAllLayers();
      setTimeout(() => this.editLayerName(newGroup.id), 0);
      return;
    }
    let topmostNode = selectedNodes[0];
    let topmostParentInfo = this.findParentNodeById(topmostNode.id);
    let insertIndex = 0;
    if (topmostParentInfo) {
      insertIndex = topmostParentInfo.node.children.indexOf(topmostNode);
    } else {
      insertIndex = this.layers.indexOf(topmostNode);
    }
    newGroup = {
      id: `group_${Date.now()}`,
      type: "group",
      name: "New Group",
      visible: true,
      locked: false,
      expanded: true,
      children: []
    };
    selectedNodes.forEach(node => {
      this.removeNodeFromParent(node.id);
      newGroup.children.push(node);
    });
    if (topmostParentInfo) {
      topmostParentInfo.node.children.splice(insertIndex, 0, newGroup);
    } else {
      this.layers.splice(insertIndex, 0, newGroup);
    }
    this.selectedLayers.clear();
    this.selectedLayers.add(newGroup.id);
    this.activeLayerId = newGroup.id;
    this.lastClickedId = newGroup.id;
    this.renderAllLayers();
    setTimeout(() => this.editLayerName(newGroup.id), 0);
    this.refreshLayerView();
  },

addItemToLayer(itemInfo = {}) {
    const newItem = {
        id: `item_${itemInfo.layer_id || Date.now()}`,
        type: "item",
        name: itemInfo.n || "New Item",
        visible: true,
        locked: false,
        children: []
    };

    let targetParent = null;
    let parentArray = this.layers;
    if (this.activeLayerId) {
        const activeNode = this.findNodeById(this.activeLayerId);
        if (activeNode) {
            if (activeNode.node.type === "item") {
                const parentInfo = this.findParentNodeById(this.activeLayerId);
                if (parentInfo) {
                    targetParent = parentInfo.node;
                    parentArray = parentInfo.node.children;
                }
            } else if (activeNode.node.type === "layer" || activeNode.node.type === "group") {
                targetParent = activeNode.node;
                parentArray = activeNode.node.children;
            }
        }
    }

    if (targetParent) {
        targetParent.expanded = true;
        parentArray.push(newItem);
    } else {
        this.layers.push(newItem);
    }

    this.selectedLayers.clear();
    this.selectedLayers.add(newItem.id);
    this.activeLayerId = newItem.id;
    this.lastClickedId = newItem.id;

    if (this.searchTerm) {
        this.handleLayerSearch(this.searchTerm);
    } else {
        this.renderAllLayers();
    }
},

refreshLayerView() {
    if (this.searchTerm) {
        this.handleLayerSearch(this.searchTerm);
    } else {
        this.renderAllLayers();
    }
},

  findParentNodeById(id, arr = this.layers) {
    for (const node of arr) {
      if (node.children && node.children.some(child => child.id === id)) {
        return { node, parentArray: arr };
      }
      if (node.children) {
        const found = this.findParentNodeById(id, node.children);
        if (found) return found;
      }
    }
    return null;
  },

handleLayerSearch(searchTerm) {
  const clearBtn = document.getElementById('clearLayerSearchBtn');
  this.searchTerm = searchTerm.toLowerCase().trim();
  
  if (this.searchTerm) {
    clearBtn.classList.remove('hidden');
  } else {
    clearBtn.classList.add('hidden');
    this.filteredLayers = null;
    this.renderAllLayers();
    return;
  }

  const filterNodes = (nodes) => {
    return nodes.map(node => {
      const nodeCopy = {
        ...node,
        type: node.type,
        name: node.name,
        visible: node.visible,
        locked: node.locked,
        expanded: node.expanded,
        id: node.id
      };
      
      if (node.children && node.children.length > 0) {
        nodeCopy.children = filterNodes(node.children);
      }

      const matchesSearch = node.name.toLowerCase().includes(this.searchTerm);
      const hasMatchingChildren = nodeCopy.children && nodeCopy.children.length > 0;

      if (matchesSearch || hasMatchingChildren) {
        if (hasMatchingChildren) {
          nodeCopy.expanded = true;
        }
        return nodeCopy;
      }
      
      return null;
    }).filter(Boolean);
  };

  const filtered = filterNodes([...this.layers]);
  this.filteredLayers = filtered.length > 0 ? filtered : null;
  this.renderAllLayers();
},

renderAllLayers() {
  const list = document.getElementById("layersList");
  list.innerHTML = "";
  list.appendChild(this.dropIndicator);
  list.appendChild(this.dragContainer);
  
  const layersToRender = this.filteredLayers || this.layers;
  layersToRender.forEach(node => {
    this.renderNode(node, list);
  });
},

  selectLayersById(layerIds) {
    if (!Array.isArray(layerIds)) {
      layerIds = [layerIds];
    }
    this.selectedLayers.clear();
    layerIds.forEach(layerId => {
      const foundLayer = this.findNodeById(layerId);
      if (foundLayer) {
        this.selectedLayers.add(layerId);
      }
    });
    if (layerIds.length > 0) {
      const firstValidLayer = layerIds.find(layerId => this.findNodeById(layerId));
      this.activeLayerId = firstValidLayer || null;
    } else {
      this.activeLayerId = null;
    }
    this.renderAllLayers();
    this.updateTransformControls();
  },

  removeLayerById(layerId) {
    const removeNodeRecursively = (id, arr) => {
      for (let i = 0; i < arr.length; i++) {
        if (arr[i].id === id) {
          arr.splice(i, 1);
          return true;
        } else if (arr[i].children && arr[i].children.length) {
          const removed = removeNodeRecursively(id, arr[i].children);
          if (removed && arr[i].children.length === 0 && arr[i].type === 'group') {
            arr.splice(i, 1);
          }
          return removed;
        }
      }
      return false;
    };
    if (removeNodeRecursively(layerId, this.layers)) {
      this.renderAllLayers();
    }
  },

  getAllChildIds(node) {
    let ids = [];
    if (node.id.startsWith('item_')) {
      ids.push(node.id);
    }
    if (node.children && node.children.length > 0) {
      node.children.forEach(child => {
        ids = ids.concat(this.getAllChildIds(child));
      });
    }
    return ids;
  },

  selectInEditor(ids) {
  const editor = window.editor_window;
  if (!editor) return;

  editor.selectedObjects = [];

  ids.forEach(id => {
    if (id.startsWith('item_')) {
      const layerId = id.replace('item_', '');
      const obj = game.roomData.items.find(item => item.layer_id === layerId);
      if (obj) editor.selectedObjects.push(obj);
    }
  });

  if (editor.selectedObjects.length > 0) {
    editor.changeMode('move');
  } else {
    editor.changeMode('select');
  }
  editor.renderSelectedTiles();
  },

  updateLockState: function(node, isLocked) {
    if (!node.visible) {
      isLocked = true;
    }
    node.locked = isLocked;
    if (node.children && node.children.length > 0) {
      node.children.forEach(child => {
        this.updateLockState(child, isLocked);
      });
    }
  },

  removeLockedOrInvisible: function(node) {
    if (node.locked || !node.visible) {
      this.selectedLayers.delete(node.id);
    }
    if (node.children && node.children.length) {
      node.children.forEach(child => {
        this.removeLockedOrInvisible(child);
      });
    }
  },

renderNode(node, parentEl) {
  const nodeContainer = document.createElement("div");
  nodeContainer.className = "node-container";
  nodeContainer.dataset.id = node.id;
  nodeContainer.dataset.type = node.type;

  const row = document.createElement("div");
  row.className = "layer-item";
  if (this.selectedLayers.has(node.id)) {
    row.classList.add("selected");
  }
  row.dataset.id = node.id;
  row.dataset.type = node.type;

  const typeIcon = document.createElement("div");
  typeIcon.className = "icon-btn";
  let iconHTML = "";
  if (node.type === "layer") {
    iconHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none"
           viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
        <path stroke-linecap="round" stroke-linejoin="round"
              d="M4 6h16M4 10h16M4 14h16M4 18h16" />
      </svg>`;
  } else if (node.type === "group") {
    iconHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none"
           viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
        <path stroke-linecap="round" stroke-linejoin="round"
              d="M3 7h4l2 2h10a2 2 0 0 1 2 2v7a2
                 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7z" />
      </svg>`;
  } else {
    iconHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4"
           viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
           stroke-linecap="round" stroke-linejoin="round">
        <polygon points="12 2, 22 8, 12 14, 2 8" fill="none" />
        <polygon points="12 14, 2 8, 2 20, 12 24" fill="none" />
        <polygon points="12 14, 22 8, 22 20, 12 24" fill="none" />
      </svg>`;
  }
  typeIcon.innerHTML = iconHTML;
  if (node.type === "layer" || node.type === "group") {
    typeIcon.addEventListener("click", (e) => {
      e.stopPropagation();
      node.expanded = !node.expanded;
      this.renderAllLayers();
    });
  }

  const eyeBtn = document.createElement("div");
  eyeBtn.className = "icon-btn";
  eyeBtn.innerHTML = node.visible
    ? `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4"
             viewBox="0 0 24 24" stroke="currentColor" fill="none"
             stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" />
          <circle cx="12" cy="12" r="3"></circle>
       </svg>`
    : `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4"
             viewBox="0 0 24 24" stroke="currentColor" fill="none"
             stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M2 2l20 20" />
          <path d="M1 12s4-8 11-8c3.31 0 5.99 1.39 8 3.27" />
          <path d="M21 12s-2-4-5-6m-7.5 9.5A3 3 0 0 1 12 9
                   c1.03 0 1.96.49 2.57 1.25M1 1l22 22"/>
       </svg>`;
  eyeBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    node.visible = !node.visible;
    if (node.id.startsWith("item_")) {
      const layerId = node.id.replace("item_", "");
      const roomItem = game.roomData.items.find(it => it.layer_id === layerId);
      if (roomItem) {
        roomItem.visible = node.visible;
      }
    }
    if (node.children && node.children.length) {
      const updateChildrenVisibility = (children, isVisible) => {
        children.forEach(child => {
          child.visible = isVisible;
          if (child.id.startsWith("item_")) {
            const layerId = child.id.replace("item_", "");
            const roomItem = game.roomData.items.find(it => it.layer_id === layerId);
            if (roomItem) {
              roomItem.visible = isVisible;
            }
          }
          if (child.children && child.children.length) {
            updateChildrenVisibility(child.children, isVisible);
          }
        });
      };
      updateChildrenVisibility(node.children, node.visible);
    }
    this.renderAllLayers();
  });

  const lockBtn = document.createElement("div");
  lockBtn.className = "icon-btn";
  lockBtn.innerHTML = node.locked
    ? `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-red-500"
             viewBox="0 0 24 24" fill="none" stroke="currentColor"
             stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <rect x="3" y="11" width="18" height="11" rx="2" ry="2" />
          <path d="M7 11V7a5 5 0 0 1 9.9-1" />
       </svg>`
    : `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-white"
             viewBox="0 0 24 24" fill="none" stroke="currentColor"
             stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <rect x="3" y="11" width="18" height="11" rx="2" ry="2" />
          <path d="M7 11V7a5 5 0 0 1 10 0v4" />
       </svg>`;
  lockBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    node.locked = !node.locked;
    this.updateLockState(node, node.locked);
    this.removeLockedOrInvisible(node);
    this.renderAllLayers();
  });

  const nameSpan = document.createElement("span");
  nameSpan.className = "layer-name";
  nameSpan.textContent = node.name;
  nameSpan.ondblclick = (evt) => {
    evt.stopPropagation();
    this.editLayerName(node.id);
  };

  const trashBtn = document.createElement("div");
  trashBtn.className = "icon-btn";
  trashBtn.innerHTML = `
    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4"
         viewBox="0 0 24 24" fill="none" stroke="currentColor"
         stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="3 6 5 6 21 6"/>
      <path d="M19 6l-2 14a2 2 0 0 1-2 2H9a2
               2 0 0 1-2-2L5 6m3 0V4a2
               2 0 0 1 2-2h4a2 2 0
               0 1 2 2v2"/>
    </svg>`;
  trashBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    this.deleteLayer(node.id);
  });

  row.appendChild(typeIcon);
  row.appendChild(eyeBtn);
  row.appendChild(lockBtn);
  row.appendChild(nameSpan);
  row.appendChild(trashBtn);

  row.addEventListener("click", (e) => {
    e.stopPropagation();
    if (node.locked) {
      this.selectedLayers.clear();
      this.selectedLayers.add(node.id);
      this.activeLayerId = node.id;
      this.lastClickedId = node.id;
      this.renderAllLayers();
      return;
    }

    if (e.ctrlKey || e.metaKey) {
      if (this.selectedLayers.has(node.id)) {
        this.selectedLayers.delete(node.id);
        if (this.activeLayerId === node.id) {
          const remaining = Array.from(this.selectedLayers);
          this.activeLayerId = remaining.length > 0 ? remaining[0] : null;
        }
      } else {
        this.selectedLayers.add(node.id);
        this.activeLayerId = node.id;
      }
      this.lastClickedId = node.id;
      const selectedIds = Array.from(this.selectedLayers).filter(id => {
        const testNode = this.findNodeById(id);
        return testNode && !testNode.node.locked;
      }).map(id => id);
      
      if (node.type === 'item') {
        const layerId = node.id.replace('item_', '');
        const roomItem = game.roomData.items.find(item => item.layer_id === layerId);
        if (roomItem) {
          editor_window.panCameraToObject(roomItem);
        }
      }
      
      this.selectInEditor(selectedIds);
      this.renderAllLayers();
      return;
    }

    let idsToSelect;
    if (e.shiftKey && this.lastClickedId) {
      this.selectRange(this.lastClickedId, node.id);
      idsToSelect = Array.from(this.selectedLayers);
    } else {
      this.selectedLayers.clear();
      this.selectedLayers.add(node.id);
      if (node.type === 'layer' || node.type === 'group') {
        idsToSelect = this.getAllChildIds(node).filter(id => {
          const childNode = this.findNodeById(id);
          return childNode && !childNode.node.locked;
        });
      } else {
        idsToSelect = [node.id];
        if (node.type === 'item') {
          const layerId = node.id.replace('item_', '');
          const roomItem = game.roomData.items.find(item => item.layer_id === layerId);
          if (roomItem) {
            editor_window.panCameraToObject(roomItem);
          }
        }
      }
    }
    this.activeLayerId = node.id;
    this.lastClickedId = node.id;
    this.renderAllLayers();
    this.selectInEditor(idsToSelect);
  });

  row.addEventListener("mousedown", (e) => {
    if (e.button !== 0) return;
    this.dragCandidate = true;
    this.dragStartX = e.clientX;
    this.dragStartY = e.clientY;
    if (this.selectedLayers.has(node.id)) {
      this.draggedNodes = this.getSelectedNodes();
    } else {
      this.draggedNodes = [node];
    }
    this.draggedEl = nodeContainer;
  });

  nodeContainer.appendChild(row);
  if ((node.type === "group" || node.type === "layer") && node.children.length) {
    const childrenContainer = document.createElement("div");
    childrenContainer.className = "children-container";
    if (!node.expanded) {
      childrenContainer.classList.add("collapsed");
    }
    node.children.forEach(child => {
      this.renderNode(child, childrenContainer);
    });
    nodeContainer.appendChild(childrenContainer);
  }
  parentEl.appendChild(nodeContainer);
},

  renderNodes() {
    const container = document.querySelector('.node-list-container');
    container.innerHTML = '';
    const nodesToRender = this.filteredNodes || this.nodeCategories;
    for (const [category, nodes] of Object.entries(nodesToRender)) {
      const categoryEl = document.createElement('div');
      categoryEl.className = 'node-category';
      const header = document.createElement('div');
      header.className = 'p-2 bg-gray-700 text-sm font-medium text-gray-300 border-b border-gray-600';
      header.textContent = category;
      categoryEl.appendChild(header);
      nodes.forEach(node => {
        const nodeEl = document.createElement('div');
        nodeEl.className = 'node-item p-2 pl-4 flex items-center gap-2 hover:bg-gray-700 cursor-grab';
        nodeEl.draggable = true;
        nodeEl.dataset.nodeId = node.id;
        const iconEl = document.createElement('div');
        iconEl.className = 'w-3 h-3 rounded-full';
        iconEl.style.backgroundColor = node.color;
        nodeEl.appendChild(iconEl);
        const nameEl = document.createElement('span');
        nameEl.className = 'text-sm text-gray-200';
        nameEl.textContent = node.name;
        nodeEl.appendChild(nameEl);
        nodeEl.addEventListener('dragstart', (e) => this.handleNodeDragStart(e));
        nodeEl.addEventListener('dragend', (e) => this.handleNodeDragEnd(e));
        categoryEl.appendChild(nodeEl);
      });
      container.appendChild(categoryEl);
    }
  },

  handleNodeDragStart(e) {
    const nodeId = e.target.dataset.nodeId;
    e.dataTransfer.setData('application/node', nodeId);
    e.target.classList.add('dragging');
    const dragImage = e.target.cloneNode(true);
    dragImage.classList.add('node-drag-preview');
    document.body.appendChild(dragImage);
    e.dataTransfer.setDragImage(dragImage, 0, 0);
    setTimeout(() => document.body.removeChild(dragImage), 0);
  },

  handleNodeDragEnd(e) {
    e.target.classList.remove('dragging');
  },

  handleNodeSearch(searchTerm) {
    if (!searchTerm || !searchTerm.trim()) {
      this.filteredNodes = null;
      const container = document.querySelector('.node-list-container');
      if (container) container.innerHTML = '';
      return;
    }
    const searchLower = searchTerm.toLowerCase();
    this.filteredNodes = {};
    for (const [category, nodes] of Object.entries(this.nodeCategories)) {
      const matchedNodes = nodes.filter(node => 
        node.name.toLowerCase().includes(searchLower) ||
        node.id.toLowerCase().includes(searchLower) ||
        category.toLowerCase().includes(searchLower)
      );
      if (matchedNodes.length > 0) {
        this.filteredNodes[category] = matchedNodes;
      }
    }
    this.renderNodes();
  },

  expandAll() {
  const expandRecursively = (nodes) => {
    for (const node of nodes) {
      if (node.type === 'layer' || node.type === 'group') {
        node.expanded = true;
        if (node.children && node.children.length > 0) {
          expandRecursively(node.children);
        }
      }
    }
  };
  expandRecursively(this.layers);
  this.renderAllLayers();
},

collapseAll() {
  const collapseRecursively = (nodes) => {
    for (const node of nodes) {
      if (node.type === 'layer' || node.type === 'group') {
        node.expanded = false;
        if (node.children && node.children.length > 0) {
          collapseRecursively(node.children);
        }
      }
    }
  };
  collapseRecursively(this.layers);
  this.renderAllLayers();
},

toggleLockAll() {
  const allLocked = this.areAllLocked(this.layers);
  const toggleRecursively = (nodes, lock) => {
    for (const node of nodes) {
      node.locked = lock;
      if (node.children && node.children.length > 0) {
        toggleRecursively(node.children, lock);
      }
    }
  };
  toggleRecursively(this.layers, !allLocked);
  this.renderAllLayers();
},

areAllLocked(nodes) {
  for (const node of nodes) {
    if (!node.locked) return false;
    if (node.children && node.children.length > 0) {
      if (!this.areAllLocked(node.children)) return false;
    }
  }
  return true;
},

  selectRange(idA, idB) {
    const visibleIds = this.getFlattenedVisibleIds();
    const idxA = visibleIds.indexOf(idA);
    const idxB = visibleIds.indexOf(idB);
    if (idxA === -1 || idxB === -1) return;
    const [start, end] = idxA < idxB ? [idxA, idxB] : [idxB, idxA];
    for (let i = start; i <= end; i++) {
      this.selectedLayers.add(visibleIds[i]);
    }
  },

  getFlattenedVisibleIds() {
    const ids = [];
    const traverse = (arr) => {
      for (const node of arr) {
        ids.push(node.id);
        if ((node.type === 'layer' || node.type === 'group') && node.expanded) {
          traverse(node.children);
        }
      }
    };
    traverse(this.layers);
    return ids;
  },

  getSelectedNodes() {
    const out = [];
    for (const id of this.selectedLayers) {
      const f = this.findNodeById(id);
      if (f) out.push(f.node);
    }
    return out;
  },

  handleMouseMove(e) {
    if (!this.dragCandidate && !this.isDragging) return;
    if (!this.isDragging) {
      const dx = e.clientX - this.dragStartX;
      const dy = e.clientY - this.dragStartY;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist > this.dragThreshold) {
        this.startDrag(e);
      }
    } else {
      this.updateDragPosition(e);
      this.checkCollision(e);
    }
  },

  handleMouseUp(e) {
    if (this.dragCandidate && !this.isDragging) {
      this.dragCandidate = false;
      if (this.draggedEl) {
        this.draggedEl.querySelector(".layer-item")?.classList.remove("pending-drag");
      }
      this.draggedNodes = [];
      this.draggedEl = null;
      return;
    }
    if (this.isDragging) {
      this.stopDrag();
    }
  },

  startDrag(e) {
    this.isDragging = true;
    this.dragCandidate = false;
    if (this.draggedEl) {
      this.draggedEl.querySelector(".layer-item")?.classList.remove("pending-drag");
    }
    const clone = document.createElement("div");
    clone.classList.add("dragging-clone");
    if (this.draggedNodes.length === 1) {
      clone.innerText = this.draggedNodes[0].name;
    } else {
      clone.innerText = `Dragging ${this.draggedNodes.length} items...`;
    }
    this.draggedClone = clone;
    const rect = this.draggedEl?.getBoundingClientRect();
    if (rect) {
      this.offsetX = e.clientX - rect.left;
      this.offsetY = e.clientY - rect.top;
    }
    this.dragContainer.appendChild(clone);
    this.updateDragPosition(e);
  },

  updateDragPosition(e) {
    if (!this.draggedClone) return;
    const panelRect = document.getElementById("layersBody").getBoundingClientRect();
    let x = e.clientX - this.offsetX;
    let y = e.clientY - this.offsetY;
    if (x < panelRect.left) x = panelRect.left;
    if (y < panelRect.top)  y = panelRect.top;
    if (x > panelRect.right - 30) x = panelRect.right - 30;
    if (y > panelRect.bottom - 20) y = panelRect.bottom - 20;
    x -= panelRect.left;
    y -= panelRect.top;
    this.draggedClone.style.transform = `translate(${x}px, ${y}px)`;
  },

  stopDrag() {
    this.isDragging = false;
    if (this.draggedClone && this.draggedClone.parentNode) {
      this.draggedClone.parentNode.removeChild(this.draggedClone);
    }
    this.draggedClone = null;
    if (this.dropPosition) {
      const { targetId, mode } = this.dropPosition;
      const found = this.findNodeById(targetId);
      for (const dn of this.draggedNodes) {
        this.removeNodeFromParent(dn.id);
      }
      if (!found) {
        this.layers.push(...this.draggedNodes);
      } else {
        const { node: targetNode, parentArray } = found;
        if (mode === "above" || mode === "below") {
          const index = parentArray.indexOf(targetNode);
          if (mode === "above") {
            parentArray.splice(index, 0, ...this.draggedNodes);
          } else {
            parentArray.splice(index+1, 0, ...this.draggedNodes);
          }
        } else if (mode === "inside") {
          if (targetNode.type === "group" || targetNode.type === "layer") {
            targetNode.expanded = true;
            targetNode.children.unshift(...this.draggedNodes);
          } else {
            const idx = parentArray.indexOf(targetNode);
            parentArray.splice(idx+1, 0, ...this.draggedNodes);
          }
        }
      }
    } else {
      for (const dn of this.draggedNodes) {
        this.removeNodeFromParent(dn.id);
      }
      this.layers.push(...this.draggedNodes);
    }
    this.dragCandidate = false;
    this.draggedNodes = [];
    this.draggedEl = null;
    this.dropPosition = null;
    this.hideDropIndicator();
    this.dragContainer.innerHTML = "";
    this.renderAllLayers();
  },

  checkCollision(e) {
    const container = document.getElementById("layersList");
    const rowContainers = container.querySelectorAll(".layer-item");
    const mouseY = e.clientY;
    let hovered = null;
    let hoveredRect = null;
    for (let i = 0; i < rowContainers.length; i++) {
      const c = rowContainers[i];
      if (this.draggedNodes.find(dn => dn.id === c.dataset.id)) {
        continue;
      }
      const r = c.getBoundingClientRect();
      if (mouseY >= r.top && mouseY <= r.bottom) {
        hovered = c;
        hoveredRect = r;
        break;
      }
    }
    if (!hovered) {
      this.dropPosition = null;
      this.hideDropIndicator();
      return;
    }
    const hoveredNodeId = hovered.dataset.id;
    const hoveredData = this.findNodeById(hoveredNodeId);
    if (!hoveredData) {
      this.dropPosition = null;
      this.hideDropIndicator();
      return;
    }
    const offsetY = mouseY - hoveredRect.top;
    const height = hoveredRect.height;
    const topZone = height * 0.33;
    const bottomZone = height * 0.66;
    if (offsetY < topZone) {
      this.dropPosition = { targetId: hoveredNodeId, mode: "above" };
      this.showDropIndicator(hovered, "above");
    } else if (offsetY > bottomZone) {
      this.dropPosition = { targetId: hoveredNodeId, mode: "below" };
      this.showDropIndicator(hovered, "below");
    } else {
      const nd = hoveredData.node;
      if (nd.type === "group" || nd.type === "layer") {
        this.dropPosition = { targetId: hoveredNodeId, mode: "inside" };
        this.showDropIndicator(hovered, "inside");
      } else {
        this.dropPosition = { targetId: hoveredNodeId, mode: "below" };
        this.showDropIndicator(hovered, "below");
      }
    }
  },

  showDropIndicator(elem, mode) {
    const rect = elem.getBoundingClientRect();
    const listRect = document.getElementById("layersList").getBoundingClientRect();
    let nestingLevel = 0;
    let parent = elem.parentElement;
    while (parent && !parent.id?.includes('layersList')) {
      if (parent.classList.contains('children-container')) {
        nestingLevel++;
      }
      parent = parent.parentElement;
    }
    const baseIndent = nestingLevel * 20;
    const indentOffset = mode === 'inside' ? 20 : 0;
    const totalIndent = baseIndent + indentOffset;
    this.dropIndicator.style.left = totalIndent + 'px';
    this.dropIndicator.style.right = '0';
    if (mode === "above") {
      this.dropIndicator.style.top = (rect.top - listRect.top) + "px";
      this.dropIndicator.style.display = "block";
    } else if (mode === "below") {
      this.dropIndicator.style.top = (rect.bottom - listRect.top - 2) + "px";
      this.dropIndicator.style.display = "block";
    } else {
      const midY = (rect.top - listRect.top) + rect.height / 2;
      this.dropIndicator.style.top = (midY - 1) + "px";
      this.dropIndicator.style.display = "block";
    }
  },

  hideDropIndicator() {
    this.dropIndicator.style.display = "none";
  },

  findNodeById(id, arr = this.layers) {
    for (let i = 0; i < arr.length; i++) {
      const n = arr[i];
      if (n.id === id) return { node: n, parentArray: arr };
      if ((n.type === "group" || n.type === "layer") && n.children) {
        const sub = this.findNodeById(id, n.children);
        if (sub) return sub;
      }
    }
    return null;
  },

  removeNodeFromParent(id) {
    const found = this.findNodeById(id);
    if (!found) return;
    const { node, parentArray } = found;
    const idx = parentArray.indexOf(node);
    if (idx !== -1) {
      parentArray.splice(idx, 1);
    }
  },

  deleteLayer(id) {
  const found = this.findNodeById(id);
  if (!found) return;

  const { node } = found;

  let itemNodeIds = this.getAllChildIds(node);
  if (node.type === 'item') {
    itemNodeIds.push(node.id);
  }

  itemNodeIds.forEach(itemNodeId => {
    const layerId = itemNodeId.replace('item_', '');
    game.roomData.items = game.roomData.items.filter(removedItem => {
      if (removedItem.layer_id !== layerId) {
        return true;
      }
      if (plugin.exists('lighting')) {
        plugin.lighting.lights =
          plugin.lighting.lights.filter(light => {
            return !light.id.startsWith(layerId + '_light_');
          });
      }
      return false;
    });
  });

  this.removeNodeFromParent(id);
  this.selectedLayers.delete(id);
  if (this.activeLayerId === id) {
    if (this.layers.length) {
      this.activeLayerId = this.layers[0].id;
    } else {
      const def = {
        id: `layer_default_${Date.now()}`,
        type: "layer",
        name: "Default Layer",
        visible: true,
        locked: false,
        expanded: true,
        children: []
      };
      this.layers.push(def);
      this.activeLayerId = def.id;
    }
  }
  this.renderAllLayers();
  this.refreshLayerView();
  },

  editLayerName(id) {
    const f = this.findNodeById(id);
    if (!f) return;
    const { node } = f;
    const span = document.querySelector(`.layer-item[data-id='${id}'] .layer-name`);
    if (!span) return;
    const container = span.closest(".layer-item");
    const w = container.offsetWidth;
    const input = document.createElement("input");
    input.type = "text";
    input.value = node.name;
    input.className = "edit-layer-name";
    input.style.width = w + "px";
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === "Escape") input.blur();
    });
    input.addEventListener("blur", () => {
      node.name = input.value.trim() || "Unnamed";
      this.renderAllLayers();
    });
    span.textContent = "";
    span.appendChild(input);
    input.focus();
    input.setSelectionRange(0, input.value.length);
  },

  toggleLayersPanel() {
    const bodyEl = document.getElementById("layersBody");
    const toggleIcon = document.getElementById("layersToggleIcon");
    this.panelOpen = !this.panelOpen;
    if (this.panelOpen) {
      bodyEl.classList.remove("hidden-panel");
      toggleIcon.classList.remove("rotate-180");
    } else {
      bodyEl.classList.add("hidden-panel");
      toggleIcon.classList.add("rotate-180");
    }
  },

  toggleNodesPanel() {
    const bodyEl = document.getElementById("nodesBody");
    const toggleIcon = document.getElementById("nodesToggleIcon");
    this.nodesPanelOpen = !this.nodesPanelOpen;
    if (this.nodesPanelOpen) {
      bodyEl.classList.remove("hidden-panel");
      toggleIcon.classList.remove("rotate-180");
    } else {
      bodyEl.classList.add("hidden-panel");
      toggleIcon.classList.add("rotate-180");
    }
  },

  togglePropertiesPanel() {
    const bodyEl = document.getElementById("propertiesBody");
    const toggleIcon = document.getElementById("propertiesToggleIcon");
    this.propertiesPanelOpen = !this.propertiesPanelOpen;
    if (this.propertiesPanelOpen) {
      bodyEl.classList.remove("hidden-panel");
      toggleIcon.classList.remove("rotate-180");
    } else {
      bodyEl.classList.add("hidden-panel");
      toggleIcon.classList.add("rotate-180");
    }
  },

  toggleSpectrumPanel() {
    const bodyEl = document.getElementById("spectrumBody");
    const toggleIcon = document.getElementById("spectrumToggleIcon");
    this.spectrumPanelOpen = !this.spectrumPanelOpen;
    if (this.spectrumPanelOpen) {
      bodyEl.classList.remove("hidden-panel");
      toggleIcon.classList.remove("rotate-180");
    } else {
      bodyEl.classList.add("hidden-panel");
      toggleIcon.classList.add("rotate-180");
    }
  },

  togglePanelSlide() {
    const panel = document.getElementById("layersPanel");
    const icon = document.getElementById("slideTabIcon");
    this.panelSlideVisible = !this.panelSlideVisible;
    if (this.panelSlideVisible) {
      panel.classList.remove("slid-off");
      icon.style.transform = "rotate(0deg)";
    } else {
      panel.classList.add("slid-off");
      icon.style.transform = "rotate(180deg)";
    }
  }
};
</script>
