<div class='text-light text-white'>
            <div id="ui_console_tab_window_tabs">
                <div id="tabs" class="flex border-b border-gray-300">
                    <button class="tab text-white bg-gray-800 hover:bg-gray-700 px-4 py-2 focus:outline-none" data-tab="debug-tools-tab">Tools</button>
                    <button class="tab text-white bg-gray-800 hover:bg-gray-700 px-4 py-2 focus:outline-none" data-tab="sprite-tab">Sprite</button>
                </div>
                <div class="tab-content p-4 hidden text-white" data-tab-content="debug-tools-tab">
                    <p>Camera Position: <span id="camera_position"></span></p>
                    <div>
                        <input type="checkbox" id="show_collision_boundaries" onchange="ui_console_tab_window.toggleCollisionBoundaries()" checked> Show Collision Boundaries
                    </div>
                    <div>
                        <input type="checkbox" id="show_walkable_tiles" onchange="ui_console_tab_window.toggleWalkableTiles()" checked> Show Nearest Walkable Tile
                    </div>
                    <div>
                        <input type="checkbox" id="show_object_collision" onchange="ui_console_tab_window.toggleObjectCollision()"> Show Object Collision
                    </div>
                    <div>
                        <label for="attack_slider">Attack:</label>
                        <input type="range" id="attack_slider" min="0" max="200" step="1" value="100" onchange="ui_console_tab_window.updateAttribute('attack', this.value)">
                        <span id="attack_value">100</span>
                    </div>
                    <div>
                        <label for="defense_slider">Defense:</label>
                        <input type="range" id="defense_slider" min="0" max="100" step="1" value="50" onchange="ui_console_tab_window.updateAttribute('defense', this.value)">
                        <span id="defense_value">50</span>
                    </div>
                    <div>
                        <label for="intensity_slider">Intensity:</label>
                        <input type="range" id="intensity_slider" min="0" max="100" step="1" value="50" onchange="ui_console_tab_window.updateAttribute('intensity', this.value)">
                        <span id="intensity_value">50</span>
                    </div>
                </div>
                <div class="tab-content p-4 hidden text-white" data-tab-content="sprite-tab">

                <div class="mt-1 mb-3">
    <button class="green_button text-white font-bold py-3 px-4 rounded w-full shadow-md" onclick="ui_console_tab_window.generateNewSprite()">Generate New Sprite</button>
</div>

<div class="mt-1 mb-3">
    <button class="red_button text-white font-bold py-3 px-4 rounded w-full shadow-md" onclick="ui_console_tab_window.removeSelectedSprite()">Remove Selected Sprite</button>
</div>
                    <p>Select Sprite:</p>
                    <select id="sprite_select" class="mb-3" style="color: black;" onchange="ui_console_tab_window.updateSelectedSprite(this.value)">
                        <option value="">Select a sprite</option>
                    </select>

                    <div class="mt-1 mb-3">
                        <button class="green_button text-white font-bold py-3 px-4 rounded w-full shadow-md" onclick="ui_console_tab_window.changeCameraToSelectedSprite()">Change Camera</button>
                    </div>

                    <div>
                        <input type="checkbox" id="is_sprite_enemy" onchange="ui_console_tab_window.updateSpriteAttribute('isEnemy', this.checked)"> Is Enemy
                    </div>

                    <div>
                        <input type="checkbox" id="show_attack_radius" onchange="ui_console_tab_window.toggleAttackRadius()"> Show Attack Radius
                    </div>

                    <div>
                        <label for="sprite_attack_slider">Attack:</label>
                        <input type="range" id="sprite_attack_slider" min="0" max="200" step="1" value="100" onchange="ui_console_tab_window.updateSpriteAttribute('attack', this.value)">
                        <span id="sprite_attack_value">100</span>
                    </div>
                    <div>
                        <label for="sprite_maxRadius_slider">Max Range:</label>
                        <input type="range" id="sprite_maxRadius_slider" min="0" max="500" step="1" value="30" onchange="ui_console_tab_window.updateSpriteAttribute('maxRange', this.value)">
                        <span id="sprite_maxRange_value">30</span>
                    </div>
                    <div>
                        <label for="sprite_defense_slider">Defense:</label>
                        <input type="range" id="sprite_defense_slider" min="0" max="100" step="1" value="50" onchange="ui_console_tab_window.updateSpriteAttribute('defense', this.value)">
                        <span id="sprite_defense_value">50</span>
                    </div>
                    <div>
                        <label for="sprite_intensity_slider">Intensity:</label>
                        <input type="range" id="sprite_intensity_slider" min="0" max="100" step="1" value="50" onchange="ui_console_tab_window.updateSpriteAttribute('intensity', this.value)">
                        <span id="sprite_intensity_value">50</span>
                    </div>
                    <div>
                        <label for="sprite_health_slider">Health:</label>
                        <input type="range" id="sprite_health_slider" min="0" max="100" step="1" value="100" onchange="ui_console_tab_window.updateSpriteHealth(this.value)">
                        <span id="sprite_health_value">100</span>
                    </div>
                    <div>
                        <label for="sprite_energy_slider">Energy:</label>
                        <input type="range" id="sprite_energy_slider" min="0" max="100" step="1" value="100" onchange="ui_console_tab_window.updateSpriteEnergy(this.value)">
                        <span id="sprite_energy_value">100</span>
                    </div>
                    <div>
                        <label for="sprite_speed_slider">Speed:</label>
                        <input type="range" id="sprite_speed_slider" min="0" max="200" step="1" value="100" onchange="ui_console_tab_window.updateSpriteAttribute('speed', this.value)">
                        <span id="sprite_speed_value">100</span>
                    </div>

                    <div class="mt-2">
                        <button class="green_button text-white font-bold py-3 px-4 rounded w-full mt-2 shadow-md" onclick="ui_console_tab_window.applyToAllSprites()">Apply to All</button>
                    </div>

                    <div class="mt-4">Appearance</div>

                    <div>
                        <label for="sprite_body_slider">Body:</label>
                        <input type="range" id="sprite_body_slider" min="0" max="5" step="1" value="1" onchange="ui_console_tab_window.updateSpriteAttribute('body', this.value)">
                        <span id="sprite_body_value">1</span>
                    </div>
                    <div>
                        <label for="sprite_head_slider">Head:</label>
                        <input type="range" id="sprite_head_slider" min="0" max="5" step="1" value="1" onchange="ui_console_tab_window.updateSpriteAttribute('head', this.value)">
                        <span id="sprite_head_value">1</span>
                    </div>
                    <div>
                        <label for="sprite_eyes_slider">Eyes:</label>
                        <input type="range" id="sprite_eyes_slider" min="0" max="5" step="1" value="1" onchange="ui_console_tab_window.updateSpriteAttribute('eyes', this.value)">
                        <span id="sprite_eyes_value">1</span>
                    </div>
                    <div>
                        <label for="sprite_hair_slider">Hair:</label>
                        <input type="range" id="sprite_hair_slider" min="0" max="29" step="1" value="0" onchange="ui_console_tab_window.updateSpriteAttribute('hair', this.value)">
                        <span id="sprite_hair_value">0</span>
                    </div>
                    <div>
                        <label for="sprite_outfit_slider">Outfit:</label>
                        <input type="range" id="sprite_outfit_slider" min="0" max="5" step="1" value="2" onchange="ui_console_tab_window.updateSpriteAttribute('outfit', this.value)">
                        <span id="sprite_outfit_value">2</span>
                    </div>
                    <div>
                        <label for="sprite_facial_slider">Facial:</label>
                        <input type="range" id="sprite_facial_slider" min="0" max="3" step="1" value="0" onchange="ui_console_tab_window.updateSpriteAttribute('facial', this.value)">
                        <span id="sprite_facial_value">0</span>
                    </div>
                    <div>
                        <label for="sprite_hat_slider">Hat:</label>
                        <input type="range" id="sprite_hat_slider" min="0" max="6" step="1" value="4" onchange="ui_console_tab_window.updateSpriteAttribute('hat', this.value)">
                        <span id="sprite_hat_value">4</span>
                    </div>
                    <div>
                        <label for="sprite_glasses_slider">Glasses:</label>
                        <input type="range" id="sprite_glasses_slider" min="0" max="2" step="1" value="0" onchange="ui_console_tab_window.updateSpriteAttribute('glasses', this.value)">
                        <span id="sprite_glasses_value">0</span>
                    </div>
                    
                    <div class="mt-4">Position</div>
                    <div>
                        <label for="sprite_x_slider">X:</label>
                        <input type="range" id="sprite_x_slider" min="0" max="500" step="1" value="0" onchange="ui_console_tab_window.updateSpriteAttribute('x', this.value)">
                        <span id="sprite_x_value">0</span>
                    </div>
                    <div>
                        <label for="sprite_y_slider">Y:</label>
                        <input type="range" id="sprite_y_slider" min="0" max="500" step="1" value="0" onchange="ui_console_tab_window.updateSpriteAttribute('y', this.value)">
                        <span id="sprite_y_value">0</span>
                    </div>
                </div>
            </div>
        </div>

    <script>
 var ui_console_tab_window = {
    interval: null,
    showCollisionBoundaries: true,
    showWalkableTiles: true,
    showAttackRadius: false,
    selectedSprite: null,
    showObjectCollision: false,
    start: function() {
        ui.initTabs('ui_console_tab_window_tabs', 'debug-tools-tab'); // Initialize the first tab as active
        this.updateDebugInfo();
        this.populateSpriteSelect(); // Populate the sprite select box
        this.interval = setInterval(this.updateDebugInfo.bind(this), 1000); // Update every second
    },
    unmount: function() {
        clearInterval(this.interval);
    },
    toggleCollisionBoundaries: function() {
        this.showCollisionBoundaries = !this.showCollisionBoundaries;
        this.updateDebugInfo(); // Refresh debug info to reflect the change
    },
    toggleObjectCollision: function() {
        this.showObjectCollision = !this.showObjectCollision;
        this.updateDebugInfo(); // Refresh debug info to reflect the change
    },
    toggleWalkableTiles: function() {
        this.showWalkableTiles = !this.showWalkableTiles;
        this.updateDebugInfo(); // Refresh debug info to reflect the change
    },
    toggleAttackRadius: function() {
        this.showAttackRadius = !this.showAttackRadius;
        this.renderAttackRadius();
    },
    truncate: function(str, maxLength) {
        return str.length > maxLength ? str.substring(0, maxLength - 3) + '...' : str;
    },
    updateAttribute: function(attribute, value) {
        const sprite = game.mainSprite;
        if (sprite) {
            sprite[attribute] = parseInt(value);
            document.getElementById(attribute + '_value').innerText = value;
        }
    },
    updateSpriteAttribute: function(attribute, value) {
        if (this.selectedSprite) {
            if (attribute === 'isEnemy') {
                this.selectedSprite[attribute] = value;
            } else {
                this.selectedSprite[attribute] = parseInt(value);
                document.getElementById('sprite_' + attribute + '_value').innerText = value;
            }
        }
    },
    updateSpriteHealth: function(value) {
    if (this.selectedSprite) {
        const newValue = parseInt(value);
        if (!isNaN(newValue)) {
            // Directly update the sprite's health
            this.selectedSprite.updateHealth(newValue - this.selectedSprite.health);
            document.getElementById('sprite_health_value').innerText = newValue;

            // Update health bar in overlay if this is the main sprite
            if (this.selectedSprite === game.mainSprite) {
                const healthBar = document.getElementById('health-bar');
                if (healthBar) {
                    const healthPercentage = (this.selectedSprite.health / this.selectedSprite.maxHealth) * 100;
                    healthBar.style.width = healthPercentage + '%';
                }
            }
        }
    }
},

updateSpriteEnergy: function(value) {
    if (this.selectedSprite) {
        const newValue = parseInt(value);
        if (!isNaN(newValue)) {
            // Directly update the sprite's energy
            this.selectedSprite.updateEnergy(newValue - this.selectedSprite.energy);
            document.getElementById('sprite_energy_value').innerText = newValue;

            // Update energy bar in overlay if this is the main sprite
            if (this.selectedSprite === game.mainSprite) {
                const energyBar = document.getElementById('energy-bar');
                if (energyBar) {
                    const energyPercentage = (this.selectedSprite.energy / this.selectedSprite.maxEnergy) * 100;
                    energyBar.style.width = energyPercentage + '%';
                }
            }
        }
    }
},
    updateSelectedSprite: function(spriteId) {
        this.selectedSprite = game.sprites[spriteId];
        if (this.selectedSprite) {
            document.getElementById('is_sprite_enemy').checked = this.selectedSprite.isEnemy;
            document.getElementById('sprite_attack_slider').value = this.selectedSprite.attack || 0;
            document.getElementById('sprite_attack_value').innerText = this.selectedSprite.attack || 0;
            document.getElementById('sprite_maxRadius_slider').value = this.selectedSprite.maxRange || 0;
            document.getElementById('sprite_maxRange_value').innerText = this.selectedSprite.maxRange || 0;
            document.getElementById('sprite_defense_slider').value = this.selectedSprite.defense || 0;
            document.getElementById('sprite_defense_value').innerText = this.selectedSprite.defense || 0;
            document.getElementById('sprite_intensity_slider').value = this.selectedSprite.intensity || 0;
            document.getElementById('sprite_intensity_value').innerText = this.selectedSprite.intensity || 0;
            document.getElementById('sprite_health_slider').value = this.selectedSprite.health || 100;
            document.getElementById('sprite_health_value').innerText = this.selectedSprite.health || 100;
            document.getElementById('sprite_energy_slider').value = this.selectedSprite.energy || 100;
            document.getElementById('sprite_energy_value').innerText = this.selectedSprite.energy || 100;
            document.getElementById('sprite_speed_slider').value = this.selectedSprite.speed || 0;
            document.getElementById('sprite_speed_value').innerText = this.selectedSprite.speed || 0;
            document.getElementById('sprite_x_slider').value = this.selectedSprite.x || 0;
            document.getElementById('sprite_x_value').innerText = this.selectedSprite.x || 0;
            document.getElementById('sprite_y_slider').value = this.selectedSprite.y || 0;
            document.getElementById('sprite_y_value').innerText = this.selectedSprite.y || 0;
        }
    },
    populateSpriteSelect: function() {
        const spriteSelect = document.getElementById('sprite_select');
        const selectedSpriteId = spriteSelect.value; // Store the currently selected sprite ID
        spriteSelect.innerHTML = '<option value="">Select a sprite</option>';
        for (const id in game.sprites) {
            const sprite = game.sprites[id];
            const option = document.createElement('option');
            option.value = id;
            option.innerText = this.truncate(id, 30); // Truncate the text to 30 characters
            spriteSelect.appendChild(option);
        }
        spriteSelect.value = selectedSpriteId; // Set the selected value again
    },
    applyToAllSprites: function() {
        const attackValue = parseInt(document.getElementById('sprite_attack_slider').value);
        const maxRangeValue = parseInt(document.getElementById('sprite_maxRadius_slider').value);
        const defenseValue = parseInt(document.getElementById('sprite_defense_slider').value);
        const intensityValue = parseInt(document.getElementById('sprite_intensity_slider').value);
        const healthValue = parseInt(document.getElementById('sprite_health_slider').value);
        const energyValue = parseInt(document.getElementById('sprite_energy_slider').value);
        const speedValue = parseInt(document.getElementById('sprite_speed_slider').value);

        for (const id in game.sprites) {
            const sprite = game.sprites[id];
            if (sprite.isEnemy) {
                sprite.attack = attackValue;
                sprite.maxRange = maxRangeValue;
                sprite.defense = defenseValue;
                sprite.intensity = intensityValue;
                sprite.updateHealth(healthValue - sprite.health);
                sprite.updateEnergy(energyValue - sprite.energy);
                sprite.speed = speedValue;
            }
        }
    },
    updateDebugInfo: function() {
        const cameraPosition = this.getCameraPosition();
        document.getElementById('camera_position').innerText = cameraPosition;

        // Update sprite select box
        this.populateSpriteSelect();
    },
    renderObjectCollision: function() {

        if (!game.roomData || !game.roomData.items) return;

        game.roomData.items.forEach(item => {
            const itemData = game.objectData[item.id];
            if (!itemData) return;

            const tileData = itemData[0]; // Assuming the first tile data group
            const xCoordinates = item.x || [];
            const yCoordinates = item.y || [];

            // Assuming the 'w' field in tileData contains an array of collision points for polygons
            if (tileData.w && Array.isArray(tileData.w)) {
                const polygonPoints = tileData.w.map(point => ({
                    x: point.x,
                    y: point.y
                }));

                // Offset polygon points based on item coordinates
                const offsetX = xCoordinates[0] * 16;
                const offsetY = yCoordinates[0] * 16;
                this.drawPolygon(polygonPoints, offsetX, offsetY);
            }
        });
    },

    drawPolygon: function(points, offsetX, offsetY, fillColor = 'rgba(255, 0, 0, 0.5)', borderColor = 'rgba(255, 0, 0, 1)') {
        if (!points || points.length < 3) return; // A valid polygon needs at least 3 points

        if (game.ctx) {
            game.ctx.beginPath();
            game.ctx.moveTo(points[0].x + offsetX, points[0].y + offsetY);

            // Draw lines to each subsequent point
            for (let i = 1; i < points.length; i++) {
                game.ctx.lineTo(points[i].x + offsetX, points[i].y + offsetY);
            }

            // Close the polygon
            game.ctx.closePath();

            // Fill the polygon
            game.ctx.fillStyle = fillColor;
            game.ctx.fill();

            // Draw the border
            game.ctx.strokeStyle = borderColor;
            game.ctx.lineWidth = 1;
            game.ctx.stroke();
        } else {
            console.error("Canvas context is not defined.");
        }
    },

    getCameraPosition: function() {
        return `X: ${camera.cameraX}, Y: ${camera.cameraY}`;
    },
renderCollisionBoundaries: function() {
    for (const id in game.sprites) {
        const sprite = game.sprites[id];
        const rectX = sprite.x;
        const rectY = sprite.y + sprite.height / 2; // Positioned halfway down the sprite's height
        const rectWidth = sprite.width;
        const rectHeight = sprite.height / 2; // The lower half of the sprite

        game.ctx.save();
        game.ctx.strokeStyle = 'white';
        game.ctx.lineWidth = 1;
        game.ctx.strokeRect(rectX, rectY, rectWidth, rectHeight); // Draw the rectangle
        game.ctx.restore();
    }
},
renderNearestWalkableTile: function() {
    for (const id in game.sprites) {
        const sprite = game.sprites[id];
        const gridX = Math.round(sprite.x / 16);
        const gridY = Math.round(sprite.y / 16);

        const directions = [
            { x: 0, y: -1 }, // N
            { x: 1, y: 0 },  // E
            { x: 0, y: 1 },  // S
            { x: -1, y: 0 }  // W
        ];

        directions.forEach(direction => {
            const newX = gridX + direction.x;
            const newY = gridY + direction.y;

            const posX = newX * 16;
            const posY = newY * 16;

            const collisionResult = collision.check(newX * 16, newY * 16, sprite);
            const isWalkable = !collisionResult.collisionDetected;

            if (collisionResult.collisionDetected || !isWalkable) {
                game.ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; // Red for unwalkable
            } else {
                game.ctx.fillStyle = 'rgba(0, 255, 0, 0.5)'; // Green for walkable
            }

            // Render the square tile
            game.ctx.fillRect(posX, posY, 16, 16);

            // Display grid information
            game.ctx.fillStyle = 'white';
            game.ctx.font = '2px Tahoma';
            game.ctx.textAlign = 'left';
            game.ctx.textBaseline = 'top';
            game.ctx.fillText(`x:${newX}`, posX + 1, posY + 1);
            game.ctx.fillText(`y:${newY}`, posX + 1, posY + 3);
            game.ctx.fillText(`${posX},${posY}`, posX + 1, posY + 6);
        });
    }
},
    renderAttackRadius: function() {
        if (!this.showAttackRadius) return; // Check if the showAttackRadius is enabled
        for (const id in game.sprites) {
            const sprite = game.sprites[id];
            if (sprite.isEnemy) {
                // Calculate dynamic stop radius based on defense and attack
                const dynamicStopRadius = Math.max(30, 100 - sprite.defense + sprite.attack);

                game.ctx.save();
                game.ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                game.ctx.lineWidth = 2;
                game.ctx.beginPath();
                game.ctx.arc(sprite.x + sprite.width / 2, sprite.y + sprite.height / 2, dynamicStopRadius, 0, 2 * Math.PI);
                game.ctx.stroke();

                // Draw the sprite's name
                game.ctx.fillStyle = 'white';
                game.ctx.font = '10px Arial';
                game.ctx.textAlign = 'center';
                game.ctx.fillText(sprite.id, sprite.x + sprite.width / 2, sprite.y - 20); // Adjust position as needed

                game.ctx.restore();
            }
        }
    },
    changeCameraToSelectedSprite: function() {
        if (this.selectedSprite) {
            game.setActiveSprite(this.selectedSprite.id);
        }
    },
    generateNewSprite: function() {
    const newSpriteId = `sprite_${Date.now()}`; // Unique ID based on the current timestamp
    const options = {
        id: newSpriteId,
        x: Math.floor(Math.random() * 50), // Random X position
        y: Math.floor(Math.random() * 50), // Random Y position
        speed: 100,
        body: 1,
        head: 1,
        eyes: 1,
        hair: 1,
        outfit: 1,
        health: 100,
        energy: 100,
        maxRange: 30,
        attack: 10,
        defense: 5,
        intensity: 1,
        isEnemy: false,
        boundaryX: 60, // Set boundary width (in tiles)
        boundaryY: 60  // Set boundary height (in tiles)
    };
    sprite.create(options);
    this.updateSelectedSprite(newSpriteId);
    this.populateSpriteSelect(); // Update the sprite select dropdown with the new sprite
},
removeSelectedSprite: function() {
    if (this.selectedSprite) {
        const spriteId = this.selectedSprite.id;
        delete game.sprites[spriteId];  // Remove the sprite from the game
        this.selectedSprite = null;  // Clear the current selection
        this.populateSpriteSelect();  // Update the sprite select dropdown
        document.getElementById('sprite_select').value = '';  // Reset the dropdown selection
        alert(`Sprite ${spriteId} has been removed.`);
    } else {
        alert("No sprite selected to remove.");
    }
}
};

ui_console_tab_window.start();

    </script>